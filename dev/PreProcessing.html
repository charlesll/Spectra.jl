<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Data Processing · Spectra documentation</title><meta name="title" content="Data Processing · Spectra documentation"/><meta property="og:title" content="Data Processing · Spectra documentation"/><meta property="twitter:title" content="Data Processing · Spectra documentation"/><meta name="description" content="Documentation for Spectra documentation."/><meta property="og:description" content="Documentation for Spectra documentation."/><meta property="twitter:description" content="Documentation for Spectra documentation."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Spectra documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Welcome to Spectra&#39;s documentation!</a></li><li><span class="tocitem">User manual</span><ul><li class="is-active"><a class="tocitem" href="PreProcessing.html">Data Processing</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Sort-X-Axis"><span>Sort X Axis</span></a></li><li><a class="tocitem" href="#Remove-spikes"><span>Remove spikes</span></a></li><li><a class="tocitem" href="#Resample-spectra"><span>Resample spectra</span></a></li><li><a class="tocitem" href="#Baseline-subtraction"><span>Baseline subtraction</span></a></li><li><a class="tocitem" href="#Smoothing"><span>Smoothing</span></a></li><li><a class="tocitem" href="#Signal-normalisation"><span>Signal normalisation</span></a></li><li><a class="tocitem" href="#Signal-extraction"><span>Signal extraction</span></a></li><li><a class="tocitem" href="#Functions-API"><span>Functions API</span></a></li></ul></li><li><a class="tocitem" href="Measurements.html">Measurements</a></li><li><a class="tocitem" href="PeakFitting.html">Peak fitting</a></li><li><a class="tocitem" href="MachineLearning.html">Machine Learning</a></li><li><a class="tocitem" href="HelperFunctions.html">Helper Functions</a></li><li><a class="tocitem" href="Tips.html">Tips</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="examples/Baseline_examples.html">Baseline examples</a></li><li><a class="tocitem" href="examples/Full_processing.html">Processing data</a></li><li><a class="tocitem" href="examples/Raman_spectrum_fitting.html">Peak fitting the Raman spectrum of a glass</a></li><li><a class="tocitem" href="examples/Smoothing.html">Smoothing data</a></li></ul></li><li><a class="tocitem" href="References.html">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User manual</a></li><li class="is-active"><a href="PreProcessing.html">Data Processing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="PreProcessing.html">Data Processing</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/charlesll/Spectra.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/charlesll/Spectra.jl/blob/master/docs/src/PreProcessing.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Data-Processing"><a class="docs-heading-anchor" href="#Data-Processing">Data Processing</a><a id="Data-Processing-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Processing" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>Spectra allows you to perform several processing steps on x-y spectral data. Below we will showcase short examples, and then you will find the documentation of the variosu functions you may want to use!</p><p>As a starting point and for the sack of example, we create two synthetic signals to play with. They will be Gaussian signals randomly sampled along two different X axis, with noise and increasing backgrounds. One of them will also have a strong spike!</p><pre><code class="language-julia hljs"># Signal creation
using Spectra, Plots

# we create a fake signal with
x_1 = rand(1000)*100
x_2 = rand(1000)*100

# create a signal that is the combination of two gaussian peaks plus a background
background_1 = 0.08 * x_1
background_2 = 0.03 * x_2

# some noise
noise_1 = 0.5*randn(1000)
noise_2 = 0.3*randn(1000)

# the full toy signals
y_1 = gaussian(x_1, 10.0, 40., 5.) .+ background_1 .+ noise_1
y_2 = gaussian(x_2, 20.0, 60., 9.) .+ background_2 .+ noise_2

# one of them will have a spike!
y_1[600] = 250.0

# make a plot of our two spectra
scatter(x_1, y_1)
scatter!(x_2, y_2)</code></pre><p><img src="fp_1.svg" alt/></p><p>We can do the following steps (not necessarily in this order):</p><ul><li><a href="PreProcessing.html#Spectra.correct_xshift"><code>correct_xshift</code></a> allows correcting X-axis shifts of your spectra from a reference value (e.g. silicon wafer reference in Raman spectroscopy). </li><li><a href="PreProcessing.html#Spectra.nm_to_invcm"><code>nm_to_invcm</code></a> or <a href="PreProcessing.html#Spectra.invcm_to_nm"><code>invcm_to_nm</code></a> convert the X axis between nanometers (nm) and wavenumbers (cm<span>$^{-1}$</span>).</li><li><a href="PreProcessing.html#Spectra.flipsp"><code>flipsp</code></a> sort the X-axis (this is necessary for some algorithms).</li><li><a href="PreProcessing.html#Spectra.resample"><code>resample</code></a> allows getting our spectra on the same X axis for convenience. </li><li><a href="PreProcessing.html#Spectra.despiking"><code>despiking</code></a> remove spikes in the signal. </li><li><a href="PreProcessing.html#Spectra.baseline"><code>baseline</code></a> allows removing the background.</li><li><a href="PreProcessing.html#Spectra.smooth"><code>smooth</code></a> allows smoothing signals.</li><li><a href="PreProcessing.html#Spectra.tlcorrection"><code>tlcorrection</code></a> corrects Raman spectra for temperature and laser wavelength effects.</li><li><a href="PreProcessing.html#Spectra.normalise"><code>normalise</code></a> allows normalising the spectra. </li><li><a href="PreProcessing.html#Spectra.extract_signal"><code>extract_signal</code></a> can extract specific portions of a signal.</li></ul><p>Thanks to Julia&#39;s multiple dispatch, those functions support different types of inputs. Of course you will receive different outputs, see the individual documentation of each function for further details. This is quite convenient as this avoid you to write your own loops to process many spectra at once.</p><p>Let&#39;s now use some of those functions below on the signal generated above.</p><h2 id="Sort-X-Axis"><a class="docs-heading-anchor" href="#Sort-X-Axis">Sort X Axis</a><a id="Sort-X-Axis-1"></a><a class="docs-heading-anchor-permalink" href="#Sort-X-Axis" title="Permalink"></a></h2><p>We can sort the data by passing an array of spectra to <a href="PreProcessing.html#Spectra.flipsp"><code>flipsp</code></a>. After that we should have not problem plotting things with lines for instance!</p><pre><code class="language-julia hljs">spectrum_1 = flipsp([x_1 y_1])
spectrum_2 = flipsp([x_2 y_2])
plot(spectrum_1[:,1], spectrum_1[:, 2])
plot!(spectrum_2[:,1], spectrum_2[:, 2])</code></pre><p><img src="fp_2.svg" alt/></p><h2 id="Remove-spikes"><a class="docs-heading-anchor" href="#Remove-spikes">Remove spikes</a><a id="Remove-spikes-1"></a><a class="docs-heading-anchor-permalink" href="#Remove-spikes" title="Permalink"></a></h2><p>OK, the plot above reveals a strong spike in one of the signals. We will treat actually both signals with <a href="PreProcessing.html#Spectra.despiking"><code>despiking</code></a> to remove possible spikes from the signals, using the default parameters.   In summary, with the default settings, <a href="PreProcessing.html#Spectra.despiking"><code>despiking</code></a> checks if any points in a spectrum differ by more than 3 sigma from the mean value of the 4 neighboring points.   You can change the default values to adjust the threshold (for more or less than 3-sigma), or to modify the number of neighboring points considered.</p><pre><code class="language-julia hljs">y_1 = despiking(x_1, y_1)
y_2 = despiking(x_2, y_2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1000-element Vector{Float64}:
  0.18817811184926136
  2.825728859381716
 18.90814929798047
  5.552506574951748
  0.5404993688493123
  7.659309584346769
  2.1166773445622216
 -0.24237392463827892
  6.111709327837205
  2.0343588470916356
  ⋮
  0.3826958219865128
  1.1071294178761881
  0.3390395700211149
  0.6241420175657777
 14.268809220590922
  1.4067235017257023
 17.99350749200591
  0.9379340582981646
  0.5396373580960956</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>You could also call <code>despiking</code> on the collection of spectra as</p><pre><code class="language-julia hljs">collection_spectra = [[x_1 y_1], [x_2 y_2]] 
ys = despiking(collection_spectra)</code></pre></div></div><h2 id="Resample-spectra"><a class="docs-heading-anchor" href="#Resample-spectra">Resample spectra</a><a id="Resample-spectra-1"></a><a class="docs-heading-anchor-permalink" href="#Resample-spectra" title="Permalink"></a></h2><p>Using <a href="PreProcessing.html#Spectra.resample"><code>resample</code></a>, we can resample a spectrum or spectra on a user-defined X axis by calling</p><pre><code class="language-julia hljs">x_new = collect(0.:0.5:100)
y_new = resample(x, y, x_new)</code></pre><p>By default, <a href="PreProcessing.html#Spectra.resample"><code>resample</code></a> uses a linear interpolation method from the <code>DataInterpolations.jl</code> package, but you can specify other methods available at <a href="https://docs.sciml.ai/DataInterpolations/stable/methods/">https://docs.sciml.ai/DataInterpolations/stable/methods/</a>.</p><p>If you have multiple spectra, it is here very interesting to provide a collection of those spectra because you will then receive an array of spectra in output, all sampled on the same X axis.</p><p>Continuing on the example shown above, we can do:</p><pre><code class="language-julia hljs">x_new = collect(0.:0.5:100)
spectra_ = [[x_1 y_1], [x_2 y_2]]
spectra_same_x = resample(spectra_, x_new)
plot(x_new, spectra_same_x)</code></pre><p><img src="fp_3.svg" alt/></p><h2 id="Baseline-subtraction"><a class="docs-heading-anchor" href="#Baseline-subtraction">Baseline subtraction</a><a id="Baseline-subtraction-1"></a><a class="docs-heading-anchor-permalink" href="#Baseline-subtraction" title="Permalink"></a></h2><p>Baseline subtraction is performed using <a href="PreProcessing.html#Spectra.baseline"><code>baseline</code></a>, which serves as the main API and wraps several dedicated baseline correction algorithms. Similarly to the other functions, you can pass x and y vectors or a x vectors and an array of y spectra. </p><p>Continuing with our example, we will do here:</p><pre><code class="language-julia hljs">ys_corrected, ys_baselines = baseline(x_new, spectra_same_x, method=&quot;arPLS&quot;)
p1 = plot(x_new, spectra_same_x)
plot!(x_new, ys_baselines, labels=[&quot;background 1&quot; &quot;background 2&quot;])</code></pre><p><img src="fp_4.svg" alt/></p><p>Other methods are available, see the Tutorials and <a href="PreProcessing.html#Spectra.baseline"><code>baseline</code></a> function documentation  for further details!</p><h2 id="Smoothing"><a class="docs-heading-anchor" href="#Smoothing">Smoothing</a><a id="Smoothing-1"></a><a class="docs-heading-anchor-permalink" href="#Smoothing" title="Permalink"></a></h2><p>Spectra smoothing can be achieved with the <a href="PreProcessing.html#Spectra.smooth"><code>smooth</code></a> function, which supports several algorithms: </p><ul><li><strong>Whittaker smoother</strong>: Custom Julia implementation based on the Matlab code of Eiler (2003). It supports both equally and unequally spaced X values.</li><li><strong>Savitzky-Golay Smoother</strong>: Provided by the <a href="https://github.com/lnacquaroli/SavitzkyGolay.jl">SavitskyGolay.jl</a> library. </li><li><strong>GCV cubic spline smoother:</strong> From the <a href="https://github.com/SciML/DataInterpolations.jl">DataInterpolations.jl</a> library.</li><li><strong>Window-based smoothers</strong>: leverage the <a href="https://github.com/JuliaDSP/DSP.jl">DSP.jl</a> library.</li></ul><p>For fine control over smoothing parameters, you can use the <a href="PreProcessing.html#Spectra.whittaker"><code>whittaker</code></a> function directly, allowing you to change weights <code>w</code> or the smoothing order <code>d</code> (also possible in <code>smooth</code>).</p><p>Continuing with our example, we will pass the matrix of baseline corrected signals to <code>smooth</code> like:</p><pre><code class="language-julia hljs">smoothed_y = smooth(x_new, spectra_same_x; method=&quot;gcvspline&quot;)

p1 = plot(x_new, spectra_same_x)
plot!(x_new, smoothed_y, labels=[&quot;smoothed 1&quot; &quot;smoothed 2&quot;])</code></pre><p><img src="fp_5.svg" alt/></p><p>Other methods are available, see the Tutorials and <a href="PreProcessing.html#Spectra.smooth"><code>smooth</code></a> function documentation  for further details!</p><h2 id="Signal-normalisation"><a class="docs-heading-anchor" href="#Signal-normalisation">Signal normalisation</a><a id="Signal-normalisation-1"></a><a class="docs-heading-anchor-permalink" href="#Signal-normalisation" title="Permalink"></a></h2><p>Using <a href="PreProcessing.html#Spectra.normalise"><code>normalise</code></a>, you can normalise signals to their maximum intensity (<code>method=&quot;intensity&quot;</code>), the area under the curve (<code>method=&quot;area&quot;</code>) or to their minimum and maximum values (minimum will be set to 0, maximum to 1) (<code>method=&quot;minmax&quot;</code>).</p><p>For instance, continuing with our example, we can do:</p><pre><code class="language-julia hljs">normalised_ys = normalise(spectra_same_x, method=&quot;intensity&quot;)
p1 = plot(x_new, normalised_ys)</code></pre><p><img src="fp_6.svg" alt/></p><p>If you want to normalize the signals by their areas, you have to pass <code>x</code> values too, like:</p><pre><code class="language-julia hljs">normalised_y = normalise(y_matrix, x, method=&quot;intensity&quot;)</code></pre><h2 id="Signal-extraction"><a class="docs-heading-anchor" href="#Signal-extraction">Signal extraction</a><a id="Signal-extraction-1"></a><a class="docs-heading-anchor-permalink" href="#Signal-extraction" title="Permalink"></a></h2><p>Extract signals in specific regions of interest using <a href="PreProcessing.html#Spectra.extract_signal"><code>extract_signal</code></a>. You can pass associated x and y values, a single spectrum in the form of a [x y] matrix, or a list of [x y] matrices.</p><p>For instance, for a single signal in which we want the values between 40 and 60, we would write:</p><pre><code class="language-julia hljs">roi = [[40. 60.]]
extracted_x, extracted_y, indices = extract_signal(x, y, roi)</code></pre><p>You can also extract the signals in different portions by using a matrix for the regions of interest. For instance, to extract signals between 20 and 40, and 60 and 80, we can do:</p><pre><code class="language-julia hljs">roi = [[20. 40.]; [60. 80.]]
extracted_x, extracted_y, indices = extract_signal(x, y, roi)</code></pre><h2 id="Functions-API"><a class="docs-heading-anchor" href="#Functions-API">Functions API</a><a id="Functions-API-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.correct_xshift" href="#Spectra.correct_xshift"><code>Spectra.correct_xshift</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">correct_xshift(x::Vector{Float64}, y::Union{Vector{Float64}, Matrix{Float64}}, shift::Float64)
correct_xshift(sps::Vector{&lt;:Matrix}, shift::Float64)</code></pre><p>Return the signal(s) corrected from a given linear <code>shift</code> at the same <code>x</code> location as the input.</p><p>Signals can be provided as y (vector or an array of ys values) for a given x vector, or as a list of [x y] arrays of signals.</p><p>Depending on the arguments, it either returns a new vector or array of <code>y</code> at  the position <code>x</code>, or a new list of corrected [x y] spectra.</p><p>This would be typically used to correct a linear shift in <code>x</code> on Raman spectra:  for instance you measured the Si wafer peak at 522.1 cm-1 while you know it is at 520.7 cm-1.  Therefore you will call this function to correct your spectra from this shift, without affecting the x values.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Spectra

# for a vector y
x = [0., 1., 2., 3.]
y = 2*x
shift = -0.1

new_y = correct_xshift(x, y, shift)

# for an array of y
x2 = [0.5, 1.3, 2.0, 4.5]
y2 = [2*x 3*x 4*x]
new_y = correct_xshift(x, y2, shift)

# for a list of x-ys
old_spectra_list = [[x, y], [x2, y2]]
new_spectra_list = corrected(old_spectra_list, shift)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/preprocessing.jl#L43-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.nm_to_invcm" href="#Spectra.nm_to_invcm"><code>Spectra.nm_to_invcm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nm_to_invcm(x::Vector{Float64}; laser_nm = 532.0)</code></pre><p>Convert absolute wavelengths in nanometers (nm) to Raman shifts in inverse centimeters (cm⁻¹),  given <code>laser_nm</code>, the wavelength of the excitation laser in nanometers.</p><p><strong>Examples</strong></p><p>If using a 532 nm laser line, you will do:</p><pre><code class="language-julia hljs">x_wavelength_nm = collect(557:1.0:560) # unit = nm
x_inv_cm = nm_to_invcm(x_wavelength_nm; laser_nm = 532.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/preprocessing.jl#L599-L612">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.invcm_to_nm" href="#Spectra.invcm_to_nm"><code>Spectra.invcm_to_nm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">invcm_to_nm(shift_inv_cm::Vector{Float64}; laser_nm=532.0)</code></pre><p>Convert Raman shifts in inverse centimeters (cm⁻¹) to absolute wavelengths in nanometers (nm),  given <code>laser_nm</code>, the wavelength of the excitation laser in nanometers.</p><p><strong>Examples</strong></p><p>If using a 532 nm laser line, you will do:</p><pre><code class="language-julia hljs">x_inv_cm = collect(557:1.0:560) # unit = cm^-1
x_wavelength_nm = invcm_to_nm(x_inv_cm; laser_nm = 532.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/preprocessing.jl#L579-L591">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.flipsp" href="#Spectra.flipsp"><code>Spectra.flipsp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">flipsp(spectra::Union{Matrix{Float64}, Vector{&lt;:Matrix}})</code></pre><p>Return the spectrum array or a list of spectra arrays sorted by their first column values (increasing x).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">
# create some unsorted signals
x = [0., 2.,5.,-1]
x2 = [0., 2.,5.,-1, 3., -10.]
y = 2*x
y2 = 2*x2

# the arrays of signals
signal_1 = [x y]
signal_2 = [x2 y2]

# a list of signal arrays
sps = [signal_1, signal_2]

# flip one signal array
flipsp(signal_1)

# you can also do this
flipsp([x y])

# flip the list of signal arrays
flipsp(sps)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/preprocessing.jl#L103-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.resample" href="#Spectra.resample"><code>Spectra.resample</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">resample(x::Vector{Float64}, y::Union{Vector{Float64}, Matrix{Float64}}, x_new::Vector{Float64}; method::String=&quot;LinearInterpolation&quot;)
resample(multiple_spectra::Vector{&lt;:Matrix{Float64}}, x_new::Vector{Float64}; method::String=&quot;LinearInterpolation&quot;)</code></pre><p>Resample a signal or signals onto a new set of x-coordinates using interpolation.</p><p><strong>Arguments</strong></p><ul><li><code>x::Vector{Float64}</code>: The original x-coordinates corresponding to the input signal(s).</li><li><code>y::Union{Vector{Float64}, Matrix{Float64}}</code>: The input signal(s) to resample.<ul><li>If <code>y</code> is a vector, it represents a single signal.</li><li>If <code>y</code> is a matrix, each column represents a separate signal.</li></ul></li><li><code>multiple_spectra::Vector{&lt;:Matrix{Float64}}</code>: A collection of spectra where each spectrum is a matrix with two columns:<ul><li>First column: x-coordinates</li><li>Second column: y-values (signal intensities)</li></ul></li><li><code>x_new::Vector{Float64}</code>: The new x-coordinates onto which the signal(s) will be resampled.</li><li><code>method::String=&quot;LinearInterpolation&quot;</code>: The interpolation method to use. Options include:<ul><li>methods available in the <code>DataInterpolations.jl</code> package: <a href="https://docs.sciml.ai/DataInterpolations/stable/methods/">https://docs.sciml.ai/DataInterpolations/stable/methods/</a>.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li>For single signal (vector) input: A vector of resampled values (<code>Vector{Float64}</code>).</li><li>For multiple signals (matrix) input: A matrix where each column corresponds to the resampled values of the respective input column (<code>Matrix{Float64}</code>).</li><li>For collection of spectra input: A matrix where each column contains the resampled y-values for the corresponding spectrum in the input collection.</li></ul><p><strong>Errors</strong></p><ul><li>Throws an error if an unsupported interpolation method is specified.</li><li>Throws an error if the dimensions of <code>x</code> and <code>y</code> do not match.</li></ul><p><strong>Methods</strong></p><p>This function provides three methods to handle different input types:</p><ol><li>Single signal: <code>resample(x::Vector{Float64}, y::Vector{Float64}, x_new::Vector{Float64})</code></li><li>Multiple signals with common x-axis: <code>resample(x::Vector{Float64}, y::Matrix{Float64}, x_new::Vector{Float64})</code></li><li>Collection of spectra: <code>resample(multiple_spectra::Vector{&lt;:Matrix{Float64}}, x_new::Vector{Float64})</code></li></ol><p><strong>Notes</strong></p><ul><li>Uses the <code>DataInterpolations.jl</code> package for interpolation.</li><li>Extrapolation beyond the range of <code>x</code> is handled using the option <code>extrapolation_right=ExtrapolationType.Extension</code> and <code>extrapolation_left=ExtrapolationType.Extension</code>.</li><li>For the collection of spectra method, each spectrum matrix must have exactly two columns: x-coordinates in the first column and y-values in the second column. However, something great: the different spectra can have different lengths!</li><li>Automatically sorts the data</li></ul><p><strong>Examples</strong></p><p><strong>Example 1: resample a vector y or a matrix of ys (multiple spectra)</strong></p><pre><code class="language-julia hljs">using Spectra, Plots

# signal creation
x = collect(0.:0.8:10.)
# create the signals with create_peaks()
peak_infos = [
    Dict(:type =&gt; :gaussian, :amplitude =&gt; 10.0, :center =&gt; 4.0, :hwhm =&gt; 0.6),
    Dict(:type =&gt; :gaussian, :amplitude =&gt; 5.0, :center =&gt; 6.0, :hwhm =&gt; 0.4),
]
ys, y = create_peaks(x, peak_infos)

# the new x axis
x_new = collect(0.:0.05:10.)

# resampling y as a vector
y2 = resample(x, y, x_new)

# resampling the ys array of the two peaks
y3 = resample(x, ys, x_new)

# plotting
p1 = scatter(x, y, label=&quot;Original data&quot;)
plot!(x_new, y2, label=&quot;Resampled y&quot;)
display(p1)

p2 = scatter(x, ys, label=&quot;Original peak data&quot;)
plot!(x_new, y3, label=&quot;Resampled peaks&quot;)
display(p2)</code></pre><p><strong>Example 2: resampling a collection of spectra</strong></p><pre><code class="language-julia hljs">x = collect(0.:0.8:10.)
y, ys = create_peaks(x, peak_infos)
x2 = collect(0.:0.8:10.)
y2, ys2 = create_peaks(x2, peak_infos)
x3 = collect(0.:0.8:10.)
y3, ys3 = create_peaks(x3, peak_infos)

spectra_ = [[x y], [x2 y2], [x3 y3]]
x_new = collect(0.:0.05:10.)
spectra_resampled = resample(spectra_, x_new)
p3 = scatter(x, [y, y2, y3], label=&quot;Original data&quot;)
plot!(x_new, spectra_resampled, label=&quot;Resampled data&quot;)
display(p3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/preprocessing.jl#L145-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.despiking" href="#Spectra.despiking"><code>Spectra.despiking</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">despiking(x::Vector{Float64}, y::Vector{Float64}; neigh::Int=4, threshold::Int=3)
despiking(x::Vector{Float64}, y::Matrix{Float64}; neigh::Int=4, threshold::Int=3)
despiking(multiple_spectra::Vector{&lt;:Matrix{Float64}}; neigh::Int=4, threshold::Int=3)</code></pre><p>Remove spikes from signal(s) based on a threshold compared to a smoothed version.</p><p>This function smooths the spectra, calculates the residual error RMSE, and replaces points above  threshold*RMSE with the average of non-spike neighboring points.</p><p><strong>Arguments</strong></p><ul><li><code>x::Vector{Float64}</code>: The x-coordinates of the signal.</li><li><code>y::Union{Vector{Float64}, Matrix{Float64}}</code>: The signal(s) to despike.<ul><li>If <code>y</code> is a vector, it represents a single signal.</li><li>If <code>y</code> is a matrix, each column represents a separate signal.</li></ul></li><li><code>multiple_spectra::Vector{&lt;:Matrix{Float64}}</code>: A collection of spectra where each spectrum is a matrix with two columns:<ul><li>First column: x-coordinates</li><li>Second column: y-values (signal intensities)</li></ul></li><li><code>neigh::Int=4</code>: Number of points around each spike to consider for calculating the replacement value.</li><li><code>threshold::Int=3</code>: Multiplier of RMSE to identify spikes (points with residuals &gt; threshold*RMSE).</li></ul><p><strong>Returns</strong></p><ul><li>For single signal input: A vector of despiked values (<code>Vector{Float64}</code>).</li><li>For multiple signals input: A matrix where each column corresponds to the despiked values of the respective input column (<code>Matrix{Float64}</code>).</li><li>For collection of spectra input: A vector of matrices, each containing the original x-coordinates and despiked y-values.</li></ul><p><strong>Methods</strong></p><p>This function provides three methods to handle different input types:</p><ol><li>Single signal: <code>despiking(x::Vector{Float64}, y::Vector{Float64}; neigh::Int=4, threshold::Int=3)</code></li><li>Multiple signals with common x-axis: <code>despiking(x::Vector{Float64}, y::Matrix{Float64}; neigh::Int=4, threshold::Int=3)</code></li><li>Collection of spectra: <code>despiking(multiple_spectra::Vector{&lt;:Matrix{Float64}}; neigh::Int=4, threshold::Int=3)</code></li></ol><p><strong>Notes</strong></p><ul><li>The function uses the <code>smooth()</code> function with the &quot;gcvspline&quot; method to create a reference smoothed signal.</li><li>Spikes are identified as points where the residual error exceeds threshold*RMSE.</li><li>Spike values are replaced with the mean of neighboring non-spike points.</li></ul><p><strong>Examples</strong></p><p><strong>Example 1: Despiking a single signal</strong></p><pre><code class="language-julia hljs">x = collect(0:0.1:10)
y = sin.(x) + 0.1*randn(length(x))
y[30] = 5.0 # Add a spike
y_clean = despiking(x, y)</code></pre><p><strong>Example 2: Despiking multiple signals with common x-axis</strong></p><pre><code class="language-julia hljs">x = collect(0:0.1:10)
y1 = sin.(x) + 0.1randn(length(x))
y2 = cos.(x) + 0.1randn(length(x))
y1[30] = 5.0 # Add a spike to first signal
y2[40] = -4.0 # Add a spike to second signal
y_matrix = hcat(y1, y2)
y_clean_matrix = despiking(x, y_matrix)</code></pre><p><strong>Example 3: Despiking a collection of spectra</strong></p><pre><code class="language-julia hljs">spectrum1 = hcat(collect(0:0.1:10), sin.(collect(0:0.1:10)) + 0.1randn(101))
spectrum1[30, 2] = 5.0 # Add a spike
spectrum2 = hcat(collect(0:0.1:8), cos.(collect(0:0.1:8)) + 0.1randn(81))
spectrum2[40, 2] = -4.0 # Add a spike
spectra_collection = [spectrum1, spectrum2]
clean_spectra = despiking(spectra_collection)</code></pre><p><strong>Errors</strong></p><ul><li>Throws an <code>ArgumentError</code> if <code>x</code> and <code>y</code> have different lengths.</li><li>Throws an <code>ArgumentError</code> if <code>neigh</code> or <code>threshold</code> are not positive integers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/preprocessing.jl#L354-L425">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.tlcorrection" href="#Spectra.tlcorrection"><code>Spectra.tlcorrection</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tlcorrection(spectrum::Matrix{Float64}, temperature_C::Float64, laser_wavelength::Float64;
             correction=&quot;long&quot;, normalisation=&quot;area&quot;, density=2210.0)
tlcorrection(x::Vector{Float64}, y::Vector{Float64}, temperature_C::Float64, laser_wavelength::Float64;
             correction=&quot;long&quot;, normalisation=&quot;area&quot;, density=2210.0)
tlcorrection(multiple_spectra::Vector{&lt;:Matrix{Float64}}, temperature_C::Float64, laser_wavelength::Float64;
             correction=&quot;long&quot;, normalisation=&quot;area&quot;, density=2210.0)</code></pre><p>Temperature and laser wavelength correction for Raman spectra using one of three  available correction equations: &quot;long&quot;, &quot;galeener&quot;, or &quot;hehlen&quot;.  Also supports optional normalization of the corrected spectra.</p><p><strong>Arguments</strong></p><ul><li><code>spectrum::Matrix{Float64}</code>: A single spectrum with x (Raman shift in cm⁻¹) and y (intensity) values in the first and second columns, respectively.</li><li><code>x::Vector{Float64}</code>: The Raman shift values in cm⁻¹.</li><li><code>y::Vector{Float64}</code>: The intensity values corresponding to <code>x</code>.</li><li><code>multiple_spectra::Vector{&lt;:Matrix{Float64}}</code>: A collection of spectra where each spectrum is a matrix with two columns (x and y values).</li><li><code>temperature_C::Float64</code>: Temperature in degrees Celsius.</li><li><code>laser_wavelength::Float64</code>: Wavelength of the excitation laser line in nanometers (nm).</li></ul><p><strong>Options</strong></p><ul><li><code>correction::String=&quot;long&quot;</code>: The equation used for the correction. Choose from:<ul><li><code>&quot;long&quot;</code>: Corrects using the Galeener equation with an additional ( nu_0^3 ) scaling factor for adimensionality (default).</li><li><code>&quot;galeener&quot;</code>: Uses the original Galeener equation without the ( nu_0^3 ) factor.</li><li><code>&quot;hehlen&quot;</code>: Applies the Hehlen equation, which includes density corrections to preserve low-frequency signals.</li></ul></li><li><code>normalisation::String=&quot;area&quot;</code>: Specifies whether to normalize the corrected signal. Options are:<ul><li><code>&quot;area&quot;</code>: Normalizes by integrating over the area under the curve.</li><li><code>&quot;intensity&quot;</code>: Normalizes by peak intensity.</li><li><code>&quot;minmax&quot;</code>: Scales between minimum and maximum values.</li><li><code>&quot;no&quot;</code>: No normalization (default is <code>&quot;area&quot;</code>).</li></ul></li><li><code>density::Float64=2210.0</code>: Density of the studied material in kg/m³, used only with the &quot;hehlen&quot; equation. Default is the density of silica glass.</li></ul><p><strong>Returns</strong></p><p>For single spectrum input (<code>x</code> and <code>y</code> or <code>spectrum</code>):</p><ul><li><code>x_out::Vector{Float64}</code>: The Raman shift values (same as input x).</li><li><code>y_corr::Vector{Float64}</code>: The corrected intensity values.</li><li><code>ese_corr::Vector{Float64}</code>: The propagated errors on the corrected intensities.</li></ul><p>For multiple spectra input (<code>multiple_spectra</code>):</p><ul><li>A vector of tuples where each tuple contains (<code>x_out</code>, <code>y_corr</code>, <code>ese_corr</code>) for a single spectrum.</li></ul><p><strong>Notes</strong></p><ul><li>The old API is not indicated but still available for backward compatibility: you can call tlcorrection(spectrum, ...) with spectrum = [x y]</li><li>This correction uses the formula reported in Galeener and Sen (1978), Mysen et al. (1982), Brooker et al. (1988) and Hehlen et al. (2010).</li><li>The &quot;galeener&quot; equation is the exact one reported in Galeener and Sen (1978), which is a modification from Shuker and Gammon (1970) for accounting of (vo - v)^4 dependence of the Raman intensity. See also Brooker et al. (1988) for further discussion.</li><li>The &quot;long&quot; equation is that of Galeener and Sen (1978) corrected by a vo^3 coefficient for removing the cubic meter dimension of the equation of &quot;galeener&quot;. This equation has been used in Mysen et al. (1982) and Le Losq et al. (2012).</li><li>The &quot;hehlen&quot; equation is that reported in Hehlen et al. (2010). It actually originates before this publication (see Brooker et al. 1988). It uses a different correction that avoid crushing the signal below 500 cm-1. THerefore, it has the advantage of keeping intact the Boson peak signal in glasses.</li></ul><p><strong>Notes</strong></p><ol><li><strong>Equations</strong>:<ul><li>The &quot;long&quot; equation is a modified version of Galeener&#39;s equation that includes a nu_0^3 scaling factor to remove cubic meter dimensions. This version has been widely used in studies such as Mysen et al. (1982) and Le Losq et al. (2012).</li><li>The &quot;galeener&quot; equation is the original form reported by Galeener and Sen (1978), which modifies Shuker and Gammon&#39;s (1970) approach to account for (vo - v)^4  dependence.</li><li>The &quot;hehlen&quot; equation, introduced by Hehlen et al. (2010), avoids signal suppression below 500 cm⁻¹, preserving features like the Boson peak in glasses.</li></ul></li><li><strong>Error Propagation</strong>:<ul><li>Errors are calculated as sqrt{y} for raw data and propagated through the correction process.</li></ul></li><li><strong>Normalization</strong>:<ul><li>If normalization is enabled, it is applied after the correction step</li></ul></li></ol><p><strong>Examples</strong></p><p><strong>Example 1: Correcting a single spectrum, provided as x-y</strong></p><pre><code class="language-julia hljs">using Spectra, Random
x = collect(100.0:1.0:1000)
y = rand(length(x)) # Example spectrum
temperature_C = 25.0
laser_wavelength = 532.0 # nm
x_out, y_corr, ese_corr = tlcorrection(x, y, temperature_C, laser_wavelength)</code></pre><p><strong>Example 2: Correcting multiple spectra</strong></p><pre><code class="language-julia hljs">spectrum1 = hcat(collect(100.0:10:1000), rand(91))
spectrum2 = hcat(collect(100.0:10:1000), rand(91))
multiple_spectra = [spectrum1, spectrum2]
corrected_spectra = tlcorrection(multiple_spectra, temperature_C, laser_wavelength)</code></pre><p><strong>Errors</strong></p><ul><li>Throws an error if an unsupported correction method is specified.</li><li>Throws an error if normalization is not one of &quot;area&quot;, &quot;intensity&quot;, &quot;minmax&quot;, or &quot;no&quot;.</li><li>Throws an error if input spectra have fewer than two columns or if no spectra are provided for multiple-spectra input.</li></ul><p><strong>References</strong></p><ul><li>Brooker et al. (1988) Journal of Raman Spectroscopy 19(2), 71-78.</li><li>Galeener and Sen (1978) Physical Review B 17 (4): 1928–33.</li><li>Hehlen (2010) Journal of Physics: Condensed Matter 22 (2): 025401.</li><li>Le Losq et al. (2012) American Mineralogist, 97, 779–790.</li><li>Mysen et al. (1982) American Mineralogist 67: 686–95.</li><li>Shuker and Gammon (1970) Physical Review Letters 25 (4): 222–25.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/tlcorrection.jl#L14-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.normalise" href="#Spectra.normalise"><code>Spectra.normalise</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalise(y::Union{Vector{Float64}, Matrix{Float64}}; x::Union{Vector{Float64}, Nothing}=nothing, method::String=&quot;intensity&quot;)</code></pre><p>Normalise the y signal(s) using one of several methods.</p><p><strong>Arguments</strong></p><ul><li><code>y::Union{Vector{Float64}, Matrix{Float64}}</code>: The input signal(s) to normalize.<ul><li>If <code>y</code> is a vector, it represents a single signal.</li><li>If <code>y</code> is a matrix, each column represents a separate signal.</li></ul></li><li><code>x::Union{Vector{Float64}, Nothing}</code>: The x-coordinates corresponding to the y values (used only for <code>&quot;area&quot;</code> normalization). Default is <code>nothing</code>.</li><li><code>method::String</code>: The normalization method to use. Options are:<ul><li><code>&quot;area&quot;</code>: Normalize by the area under the curve (requires <code>x</code>).</li><li><code>&quot;intensity&quot;</code>: Normalize by dividing by the maximum intensity.</li><li><code>&quot;minmax&quot;</code>: Normalize to the range <code>[0, 1]</code>.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li>A normalized vector or matrix of signals (<code>Vector{Float64}</code> or <code>Matrix{Float64}</code>).</li></ul><p><strong>Notes</strong></p><ul><li>For <code>&quot;area&quot;</code> normalization, you must provide an x vector with the same length as each column of y.</li><li>If using <code>&quot;intensity&quot;</code> or <code>&quot;minmax&quot;</code>, no x vector is required.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Spectra, Plots

# Single signal normalization

x = collect(0.:0.1:10.)

# create a signal that is the combination of two gaussian peaks
y, ys = gaussiennes([10.,5.], [5.,6.], [1.,0.1], x)

# normalise the signal by area
y_norm = normalise(y; x=x, method=&quot;area&quot;)
plot(x, y_norm)

# Or normalise multiple signals, such as the two peaks created above (no need of the x axis in this case):

peaks_norm = normalise(ys, method=&quot;intensity&quot;)
plot(x, y_norm)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/preprocessing.jl#L280-L324">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.extract_signal" href="#Spectra.extract_signal"><code>Spectra.extract_signal</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extract_signal(x::Vector{Float64}, y::Vector{Float64}, roi::Matrix{Float64}) -&gt; Tuple{Vector{Float64}, Vector{Float64}, Vector{Int}}
extract_signal(spectrum::Matrix{Float64}, roi::Matrix{Float64})
extract_signal(multiple_spectra::Vector{&lt;:Matrix{Float64}}, roi::Matrix{Float64})</code></pre><p>Extract the <code>x</code>-<code>y</code> spectral values in specified regions of interest (ROI) and their indices.</p><p>You can pass associated x and y values, a single spectrum in the form of a [x y] matrix, or a list of [x y] matrices.</p><p><strong>Arguments</strong></p><ul><li><code>x::Vector{Float64}</code>: The x-axis values.</li><li><code>y::Vector{Float64}</code>: The corresponding y-axis values.</li><li><code>spectrum::Matrix{Float64}</code>: A matrix of size <code>n x 2</code>, where:<ul><li>Column 1: x-axis values.</li><li>Column 2: y-axis values.</li></ul></li><li><code>multiple_spectra::Vector{&lt;:Matrix{Float64}}</code>: A collection of spectra, where each spectrum is a matrix with two columns:<ul><li>First column: x-coordinates</li><li>Second column: y-values (signal intensities)</li></ul></li><li><code>roi::Matrix{Float64}</code>: A matrix of size <code>n x 2</code>, where each row specifies a region of interest:<ul><li>Column 1: Lower bounds of the ROI.</li><li>Column 2: Upper bounds of the ROI.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li>if calling <code>extract_signal(x, y, roi)</code>, it returns a tuple containing:<ol><li><code>Vector{Float64}</code>: The x values within the ROI.</li><li><code>Vector{Float64}</code>: The y values within the ROI.</li><li><code>Vector{Int}</code>: The indices of the x and y values within the ROI.</li></ol></li><li>if calling <code>extract_signal(spectrum, roi)</code>, it returns a tuple containing:<ol><li><code>Vector{Float64}</code>: The x values within the ROI.</li><li><code>Vector{Float64}</code>: The y values within the ROI.</li><li><code>Vector{Int}</code>: The indices of the x and y values within the ROI.</li></ol></li><li>if calling <code>extract_signal(multiple_spectra, roi)</code>, it returns a vector of tuples, where each tuple corresponds to a spectrum and contains:<ol><li><code>Vector{Float64}</code>: The x values within the ROI.</li><li><code>Vector{Float64}</code>: The y values within the ROI.</li><li><code>Vector{Int}</code>: The indices of the x and y values within the ROI.</li></ol></li></ul><p><strong>Errors</strong></p><ul><li>Throws an error if <code>x</code> and <code>y</code> have different lengths.</li><li>Throws an error if <code>roi</code> is not a 2D matrix with exactly 2 columns.</li></ul><p><strong>Notes</strong></p><ul><li>The function sorts both <code>x</code>-<code>y</code> pairs and the ROI for safety before processing.</li><li>Multiple ROIs are supported, and their results are concatenated.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/preprocessing.jl#L481-L524">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.baseline" href="#Spectra.baseline"><code>Spectra.baseline</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">baseline(x_input::Vector{Float64}, y_input::Vector{Float64}; roi::Union{Matrix{Float64}, Nothing} = nothing, method::String = &quot;polynomial&quot;, kwargs...)
baseline(x_input::Vector{Float64}, y_input::Matrix{Float64}; roi::Union{Matrix{Float64}, Nothing} = nothing,  method::String = &quot;polynomial&quot;, kwargs...)
baseline(multiple_spectra::Vector{&lt;:Matrix{Float64}}; roi::Union{Matrix{Float64}, Nothing} = nothing,  method::String = &quot;polynomial&quot;, kwargs...)</code></pre><p>Subtract a baseline from a spectrum <code>y</code> sampled at <code>x</code> values, or a set of spectra, using specified methods  that can either fit regions of interests (roi) defined by the user, or use automatic algorithms.</p><p><strong>Arguments</strong></p><ul><li><code>x_input::Vector{Float64}</code>: The x-axis values (e.g., wavelengths or time points).</li><li><code>y_input::Union{Vector{Float64}, Matrix{Float64}}</code>: The spectral data to correct. Can be a single spectrum (vector) or multiple spectra (matrix).</li><li><code>multiple_spectra::Vector{&lt;:Matrix{Float64}}</code>: A collection of spectra, where each spectrum is a matrix with two columns:<ul><li>First column: x-coordinates</li><li>Second column: y-values (signal intensities)</li></ul></li><li><code>roi::Union{Matrix{Float64}, Nothing}</code>: Regions of interest for baseline fitting, specified as a matrix where each row defines a range <code>[start, end]</code>. Default is <code>nothing</code>.</li><li><code>method::String</code>: The baseline fitting method. Default is <code>&quot;polynomial&quot;</code>. Supported methods:<ul><li><code>&quot;polynomial&quot;</code> or <code>&quot;poly&quot;</code>: Polynomial fitting.</li><li><code>&quot;Dspline&quot;</code>: 1D spline fitting using Dierckx library.</li><li><code>&quot;gcvspline&quot;</code>: Generalized Cross Validation Spline fitting.</li><li><code>&quot;exp&quot;</code>: Exponential background fitting.</li><li><code>&quot;log&quot;</code>: Logarithmic background fitting.</li><li><code>&quot;rubberband&quot;</code>: Rubberband baseline fitting.</li><li><code>&quot;als&quot;</code>: Asymmetric least squares baseline fitting.</li><li><code>&quot;arPLS&quot;</code>: Asymmetrically reweighted penalized least squares fitting.</li><li><code>&quot;drPLS&quot;</code>: Doubly reweighted penalized least squares fitting.</li></ul></li></ul><p><strong>Keyword Arguments</strong></p><p>Optional parameters for specific methods:</p><ul><li><code>polynomial_order::Int</code>: Degree of polynomial for polynomial fitting. Default is <code>1</code>.</li><li><code>s::Float64</code>: Smoothing coefficient for spline methods. Default is <code>2.0</code>.</li><li><code>lambda::Float64</code>: Smoothness parameter for ALS, arPLS, drPLS, and Whittaker methods.</li><li><code>p::Float64</code>: Parameter for ALS algorithm. Default is <code>0.01</code>.</li><li><code>ratio::Float64</code>: Parameter for arPLS and drPLS algorithms. Default is <code>0.01</code>.</li><li><code>niter::Int</code>: Number of iterations for ALS and drPLS algorithms. Default is <code>10</code>.</li><li><code>eta::Float64</code>: Roughness parameter for drPLS algorithm. Default is <code>0.5</code>.</li><li><code>d::Int</code>: Order of differences for smoothing algorithms. Default is <code>2</code>.</li><li><code>d_gcv::Int</code>: Order of differences for GCV spline algorithm. Default is <code>3</code>.</li><li><code>p0_exp::Vector{Float64}</code>: Initial parameters for exponential fitting. Default is <code>[1., 1., 1.]</code>.</li><li><code>p0_log::Vector{Float64}</code>: Initial parameters for logarithmic fitting. Default is <code>[1., 1., 1., 1.]</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>corrected_signal::Union{Vector{Float64}, Matrix{Float64}}</code>: Baseline-corrected signal(s).</li><li><code>baseline::Union{Vector{Float64}, Matrix{Float64}}</code>: Calculated baseline(s).</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If providing a collection of spectra, you will receive a collection of tuples (corrected_signal, baseline)</p></div></div><p><strong>Examples</strong></p><p><strong>Correcting a single spectrum:</strong></p><pre><code class="language-julia hljs">x = collect(50:1.0:500)
background = 10.0 .* sin.(x./50.0) + 0.1.*x
y = 50.0 .* exp.(-log(2) .* ((x .-250.0)./1.0).^2) + background
y_corrected, y_baseline = baseline(x, y, method=&quot;drPLS&quot;)</code></pre><p><strong>Correcting with regions of interest, GCV spline method:</strong></p><pre><code class="language-julia hljs">roi = [[50.0, 200.0], [300.0, 500.0]]
y_corrected, y_baseline = baseline(x, y, roi=roi, method=&quot;gcvspline&quot;)</code></pre><p>You can also adjust manually the smoothing spline coefficient <code>s</code>:</p><pre><code class="language-julia hljs">y_corrected, y_baseline = baseline(x, y, roi=roi, method=&quot;gcvspline&quot;, s=1.0)</code></pre><p><strong>Using a vector or arrays of y values:</strong></p><pre><code class="language-julia hljs">using Spectra, Plots

# we create a fake signal with 2 peaks plus 2 backgrounds
x = collect(0.:0.2:10.)

# create the signals with create_peaks()
peak_infos = [
    Dict(:type =&gt; :gaussian, :amplitude =&gt; 10.0, :center =&gt; 4.0, :hwhm =&gt; 0.6),
    Dict(:type =&gt; :gaussian, :amplitude =&gt; 5.0, :center =&gt; 6.0, :hwhm =&gt; 0.4),
]
ys, _ = create_peaks(x, peak_infos)

# add backgrounds
ys[:,1] = ys[:,1] .+ 0.1 * x
ys[:,2] = ys[:,2] .+ 0.2 * x

# fit the background on the first peak: provide as a vector
y_corr, base_ = baseline(x, ys[:,1], method=&quot;als&quot;)
p1 = plot(x, ys[:,1])
plot!(x, base_)
display(p1)

# Fit the background on multiple peaks: just provide the array!
y_corr, base_ = baseline(x, ys, method=&quot;als&quot;)
p2 = plot(x, ys, label=[&quot;signal 1&quot; &quot;signal 2&quot;])
plot!(x, base_, label=[&quot;background 1&quot; &quot;background 2&quot;])
display(p2)
````
## Treating a collection of y values:

Given x1, y1 and x2, y2 two signals, we can create a collection of spectra
and pass it to baseline():</code></pre><p>julia collection<em>sp = [[x1 y1], [x2 y2]] collected</em>baselines = baseline(collection<em>sp, method=&quot;als) ```<code>The</code>collected</em>baselines` is then a vector that contains tuples of (y_corrected, baseline).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/baseline.jl#L15-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.als_baseline" href="#Spectra.als_baseline"><code>Spectra.als_baseline</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">als_baseline(x::Vector{Float64}, y::Vector{Float64}; lambda::Float64=1.0e5, p::Float64=0.01, niter::Int=50, d::Int=2) -&gt; Vector{Float64}</code></pre><p>Estimate the baseline of a signal using the Asymmetric Least Squares (ALS) method.</p><p><strong>Arguments</strong></p><ul><li><code>x::Vector{Float64}</code>: The x-axis values (must be increasing).</li><li><code>y::Vector{Float64}</code>: The corresponding y-axis values.</li><li><code>lambda::Float64=1.0e5</code>: Smoothing parameter; larger values result in smoother baselines.</li><li><code>p::Float64=0.01</code>: Asymmetry parameter; typically between 0.001 and 0.1.</li><li><code>niter::Int=50</code>: Number of iterations for the algorithm.</li><li><code>d::Int=2</code>: Order of differences for the penalty term.</li></ul><p><strong>Returns</strong></p><ul><li><code>z::Vector{Float64}</code>: The estimated baseline.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This method uses an iterative approach to minimize the asymmetric least squares error, making it suitable for signals with varying background intensity.</p></div></div><p><strong>References</strong></p><p>G. Eilers and H. Boelens, &quot;Baseline correction with asymmetric least squares smoothing&quot; 2005.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/baseline.jl#L321-L343">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.arPLS_baseline" href="#Spectra.arPLS_baseline"><code>Spectra.arPLS_baseline</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">arPLS_baseline(x::Vector{Float64}, y::Vector{Float64}; lambda::Float64=1.0e5, ratio::Float64=0.01, d::Int=2) -&gt; Vector{Float64}</code></pre><p>Estimate the baseline of a signal using the Adaptive Reweighted Penalized Least Squares (arPLS) method.</p><p><strong>Arguments</strong></p><ul><li><code>x::Vector{Float64}</code>: The x-axis values (must be increasing).</li><li><code>y::Vector{Float64}</code>: The corresponding y-axis values.</li><li><code>lambda::Float64=1.0e5</code>: Smoothing parameter; larger values result in smoother baselines.</li><li><code>ratio::Float64=0.01</code>: Convergence ratio for stopping criterion.</li><li><code>d::Int=2</code>: Order of differences for the penalty term.</li></ul><p><strong>Returns</strong></p><ul><li><code>z::Vector{Float64}</code>: The estimated baseline.</li></ul><p><strong>Notes</strong></p><p>The arPLS algorithm iteratively adjusts weights based on residuals to improve baseline estimation accuracy.</p><p><strong>References</strong></p><p>Baek et al., &quot;Baseline correction using adaptive iteratively reweighted penalized least squares,&quot; Analyst 140 (2015): 250–257.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/baseline.jl#L389-L409">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.drPLS_baseline" href="#Spectra.drPLS_baseline"><code>Spectra.drPLS_baseline</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">drPLS_baseline(x::Vector{Float64}, y::Vector{Float64}; lambda::Float64=1.0e5, niter::Int=50, eta::Float64=0.5, ratio::Float64=0.001, d::Int=2) -&gt; Vector{Float64}</code></pre><p>Perform baseline correction using the Doubly Reweighted Penalized Least Squares (drPLS) algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>x::Vector{Float64}</code>: The x-axis values (must be increasing).</li><li><code>y::Vector{Float64}</code>: The corresponding y-axis values.</li><li><code>lambda::Float64=1.0e5</code>: Smoothing parameter; larger values result in smoother baselines.</li><li><code>niter::Int=50</code>: Maximum number of iterations for the algorithm.</li><li><code>eta::Float64=0.5</code>: Parameter controlling the influence of weights in the penalty term.</li><li><code>ratio::Float64=0.001</code>: Convergence threshold for stopping criterion.</li><li><code>d::Int=2</code>: Order of differences for the penalty term.</li></ul><p><strong>Returns</strong></p><ul><li><code>baseline_fitted::Vector{Float64}</code>: The estimated baseline.</li></ul><p><strong>Notes</strong></p><p>The drPLS algorithm builds on arPLS by introducing an additional reweighting scheme to improve robustness against noise and outliers.</p><p><strong>References</strong></p><p>Xu et al., &quot;Baseline correction method based on doubly reweighted penalized least squares,&quot; Applied Optics 58 (2019): 3913–3920.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/baseline.jl#L462-L484">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.rubberband_baseline" href="#Spectra.rubberband_baseline"><code>Spectra.rubberband_baseline</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rubberband_baseline(x::Vector{Float64}, y::Vector{Float64}; segments=1) -&gt; Vector{Float64}</code></pre><p>Estimate a baseline using the rubberband method based on the lower convex hull.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function is currently under development and may not behave as intended in all cases. !!</p></div></div><p><strong>Arguments</strong></p><ul><li><code>x::Vector{Float64}</code>: The x-axis values of the data.</li><li><code>y::Vector{Float64}</code>: The corresponding y-axis values.</li><li><code>segments</code> (optional): Specifies how to segment the data:<ul><li>If an integer, splits the data into equally sized segments (default is 1).</li><li>If a vector of integers, specifies exact indices where segmentation occurs.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>baseline_fitted::Vector{Float64}</code>: The estimated baseline as a lower envelope of the data.</li></ul><p><strong>Raises</strong></p><ul><li>Throws an error if <code>x</code> and <code>y</code> have different lengths.</li><li>Throws an error if a segment does not contain enough points for interpolation.</li></ul><p><strong>Notes</strong></p><p>The rubberband method estimates a baseline by:</p><ol><li>Identifying local minima to approximate the lower envelope.</li><li>Computing the convex hull of these points.</li><li>Interpolating between convex hull points to generate a smooth baseline.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/baseline.jl#L566-L595">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.smooth" href="#Spectra.smooth"><code>Spectra.smooth</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">smooth(x::Vector{Float64}, y::Union{Vector{Float64}, Matrix{Float64}}; 
       method::String = &quot;gcvspline&quot;, 
       window_length::Int = 5, 
       polyorder::Int = 2, 
       lambda::Float64 = 10.0^5, 
       d::Int = 2, 
       w = nothing, 
       d_gcv::Int = 3)</code></pre><p>Smooth a signal using various smoothing methods.</p><p><strong>Arguments</strong></p><ul><li><code>x::Vector{Float64}</code>: The x-coordinates of the input signal (e.g., time or spatial values).</li><li><code>y::Union{Vector{Float64}, Matrix{Float64}}</code>: The y-coordinates of the input signal to be smoothed.</li><li><code>method::String</code>: The smoothing method to use. Options include:<ul><li><code>&quot;whittaker&quot;</code>: Whittaker smoother, which uses weights (<code>w</code>) and smoothing parameter (<code>lambda</code>).</li><li><code>&quot;gcvspline&quot;</code>: Generalized cross-validation spline smoothing (requires <code>DataInterpolations.jl</code>).</li><li><code>&quot;flat&quot;</code>: Moving average.</li><li><code>&quot;hanning&quot;</code>, <code>&quot;hamming&quot;</code>, <code>&quot;bartlett&quot;</code>, <code>&quot;blackman&quot;</code>: Window-based smoothing methods (requires <code>DSP.jl</code>).</li><li><code>&quot;savgol&quot;</code>: Savitzky-Golay filter.</li></ul></li><li><code>window_length::Int</code>: The length of the smoothing window (used in window-based and Savitzky-Golay methods). Must be a positive odd integer</li><li><code>polyorder::Int</code>: The polynomial order for the Savitzky-Golay filter. Must be less than <code>window_length</code></li><li><code>lambda::Float64</code>: Smoothing parameter for the Whittaker smoother. Higher values result in smoother fits</li><li><code>d::Int</code>: Order of differences for the Whittaker smoother. Default is 2.</li><li><code>w</code>: Weights for the Whittaker smoother. size(w) should be equal to size(y). If not provided (<code>nothing</code>), uniform weights are used by default.</li><li><code>d_gcv::Int</code>: Order of differences for the GCV spline algorithm (used in <code>&quot;gcvspline&quot;</code>)</li></ul><p><strong>Returns</strong></p><ul><li>A smoothed vector or matrix of signals (<code>Vector{Float64}</code> or <code>Matrix{Float64}</code>).</li></ul><p><strong>Notes</strong></p><ul><li><strong>Deprecated Methods</strong>: The methods <code>&quot;GCVSmoothedNSpline&quot;</code>, <code>&quot;MSESmoothedNSpline&quot;</code>, and <code>&quot;DOFSmoothedNSpline&quot;</code> are no longer supported and will throw an error if used.</li><li>For window-based methods (<code>&quot;flat&quot;</code>, <code>&quot;hanning&quot;</code>, etc.), the signal is symmetrically extended at both ends to reduce edge effects.</li><li>The Savitzky-Golay filter requires that <code>window_length</code> be a positive odd integer and that <code>polyorder</code> be less than <code>window_length</code>.</li><li>For Whittaker smoothing, if weights (<code>w</code>) are provided, they must have the same length as <code>x</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Spectra, Plots

x = collect(1:10)
y = [1.0, 2.5, 3.0, 4.2, 5.1, 6.0, 7.3, 8.1, 9.4, 10.0]
method = &quot;hanning&quot;
window_length = 3

smoothed_y = smooth(x, y; method=method, window_length=window_length)
p1 = plot(x, [y smoothed_y], label=[&quot;Original&quot; &quot;Smoothed&quot;], title=&quot;Smoothing Example&quot;, xlabel=&quot;X-axis&quot;, ylabel=&quot;Y-axis&quot;)
display(p1)</code></pre><p><strong>Errors</strong></p><ul><li>Throws an error if an unsupported or deprecated method is specified.</li><li>Throws an error if <code>window_length</code> is not a positive odd integer.</li><li>For Savitzky-Golay smoothing:<ul><li>Throws an error if <code>polyorder</code> is greater than or equal to <code>window_length</code>.</li></ul></li><li>For Whittaker smoothing:<ul><li>Throws an error if weights (<code>w</code>) are provided but do not match the length of <code>x</code>.</li></ul></li></ul><p><strong>References</strong></p><ul><li>For Window-based filtering,see DSP.jl documentation: <a href="https://docs.juliadsp.org/stable/windows/">https://docs.juliadsp.org/stable/windows/</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/smoothing.jl#L110-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.whittaker" href="#Spectra.whittaker"><code>Spectra.whittaker</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">whittaker(x::Vector{Float64}, y::Vector{Float64}, w::Vector{Float64}, lambda::Float64; d::Int=2) -&gt; Vector{Float64}</code></pre><p>Smooth a signal using the Whittaker smoother with divided differences.</p><p><strong>Arguments</strong></p><ul><li><code>x::Vector{Float64}</code>: The x-axis values of the data (must be increasing).</li><li><code>y::Vector{Float64}</code>: The corresponding y-axis values, assumed to be sampled at equal intervals.</li><li><code>w::Vector{Float64}</code>: Weights for each data point. Higher weights indicate greater importance in smoothing.</li><li><code>lambda::Float64</code>: Smoothing parameter; larger values result in smoother outputs. It is recommended to be set based on the length of <code>x</code>.</li><li><code>d::Int=2</code>: Order of differences for the penalty term (default is 2).</li></ul><p><strong>Returns</strong></p><ul><li><code>z::Vector{Float64}</code>: The smoothed y-axis values.</li></ul><p><strong>Notes</strong></p><ul><li>For equally spaced x values, higher-order differences are computed manually.</li><li>For unequally spaced x values, a difference matrix is constructed using the <code>ddmat</code> function.</li><li>A sparse matrix representation is used for computational efficiency.</li></ul><p><strong>References</strong></p><ul><li>Eilers, P.H.C. (2003). &quot;A perfect smoother.&quot; Analytical Chemistry, 75, 3631–3636.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Spectra, Random, Plots
x = sort(rand(50) .* 10)                 # Randomly spaced x values in [0, 10]
true_y = sin.(x)
y = true_y .+ 0.1 .* randn(length(x))  # Noisy sine wave
w = ones(length(x))                     # Equal weights
lambda = 0.1                          # Smoothing parameter, !!! its value depends on the length of x !!!
z = whittaker(x, y, w, lambda; d=2)

p1 = plot(x, true_y); plot!(x, y); plot!(x, z), display(p1)</code></pre><p>Matlab version by Paul Eilers, 2003 Julia translation by Charles Le Losq 2017, revised 2025</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/smoothing.jl#L2-L41">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Welcome to Spectra&#39;s documentation!</a><a class="docs-footer-nextpage" href="Measurements.html">Measurements »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Saturday 3 May 2025 21:02">Saturday 3 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
