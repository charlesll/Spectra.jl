<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Peak fitting · Spectra documentation</title><meta name="title" content="Peak fitting · Spectra documentation"/><meta property="og:title" content="Peak fitting · Spectra documentation"/><meta property="twitter:title" content="Peak fitting · Spectra documentation"/><meta name="description" content="Documentation for Spectra documentation."/><meta property="og:description" content="Documentation for Spectra documentation."/><meta property="twitter:description" content="Documentation for Spectra documentation."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Spectra documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Welcome to Spectra&#39;s documentation!</a></li><li><span class="tocitem">User manual</span><ul><li><a class="tocitem" href="PreProcessing.html">Data Processing</a></li><li><a class="tocitem" href="Measurements.html">Measurements</a></li><li class="is-active"><a class="tocitem" href="PeakFitting.html">Peak fitting</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Fitting-procedure"><span>Fitting procedure</span></a></li><li><a class="tocitem" href="#Errors-on-peak-parameters"><span>Errors on peak parameters</span></a></li><li><a class="tocitem" href="#Final-remarks"><span>Final remarks</span></a></li><li><a class="tocitem" href="#Functions-API"><span>Functions API</span></a></li></ul></li><li><a class="tocitem" href="MachineLearning.html">Machine Learning</a></li><li><a class="tocitem" href="HelperFunctions.html">Helper Functions</a></li><li><a class="tocitem" href="Tips.html">Tips</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="examples/Baseline_examples.html">Baseline examples</a></li><li><a class="tocitem" href="examples/Full_processing.html">Processing data</a></li><li><a class="tocitem" href="examples/Raman_spectrum_fitting.html">Peak fitting the Raman spectrum of a glass</a></li><li><a class="tocitem" href="examples/Smoothing.html">Smoothing data</a></li></ul></li><li><a class="tocitem" href="References.html">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User manual</a></li><li class="is-active"><a href="PeakFitting.html">Peak fitting</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="PeakFitting.html">Peak fitting</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/charlesll/Spectra.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/charlesll/Spectra.jl/blob/master/docs/src/PeakFitting.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Peak-fitting"><a class="docs-heading-anchor" href="#Peak-fitting">Peak fitting</a><a id="Peak-fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Peak-fitting" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>Spectra allows to fit a spectrum with a sum of peaks, of different shapes. For that, we rely on the peak shape functions <a href="PeakFitting.html#Spectra.gaussian"><code>gaussian</code></a>, <a href="PeakFitting.html#Spectra.lorentzian"><code>lorentzian</code></a>, <a href="PeakFitting.html#Spectra.pseudovoigt"><code>pseudovoigt</code></a> and <a href="PeakFitting.html#Spectra.pearson7"><code>pearson7</code></a>. Using those, you can generate a signal given <code>x</code>, and peak parameters. To generate a signal composed of multiple contributions from different peaks, use the <a href="PeakFitting.html#Spectra.create_peaks"><code>create_peaks</code></a> function. It is a useful function for instance to create &quot;fake&quot; signals and test our peak fitting function, <a href="PeakFitting.html#Spectra.fit_peaks"><code>fit_peaks</code></a>. </p><p><a href="PeakFitting.html#Spectra.fit_peaks"><code>fit_peaks</code></a> uses either Optim.jl or a custom quasi-Newton algorithm to fit the sum of the peaks <span>$y_{calc}$</span> to an observed signal <span>$y$</span> affected by errors <span>$\sigma_y$</span>. The regression also takes into account <em>à priori</em> errors <span>$\sigma_{m_{prior}}$</span> on prior model parameters <span>$m_{prior}$</span>: we assume a Gaussian <em>prior</em> on model parameters with a mean <span>$m_{prior}$</span> and a covariance matrix <span>$C_M$</span> which diagonal contains <span>$\sigma_{m_{prior}}^2$</span>.</p><p>Given the forward calculation of <span>$y_{calc}$</span> as</p><p class="math-container">\[y_{calc} = g(m)\]</p><p>with <span>$m$</span> the model parameters and <code>g</code> the forward model, the misfit function <span>$S$</span> is (<a href="https://epubs.siam.org/doi/book/10.1137/1.9780898717921">Tarantola 2005</a>, chapter 3, eq. 3.46):</p><p class="math-container">\[S(m) = \frac{1}{2}[(y - y_{calc})^{t} C_D^{-1}(y - y_{calc}) + (m - m_{prior})^{t}C_M^{-1}(m-m_{prior})]\]</p><p>where <span>$C_D^{-1}$</span> is the inverse of the data covariance matrix, which diagonal contains <span>$\sigma_y^2$</span>. The misfit function is related to the posterior probability density in the model space following <span>$K \exp (-S(m))$</span>, with <span>$K$</span> a constant. Here, we are dealing with a non-linear problem so this posterior probability density is not Gaussian. However, we assume that it can be linearized near <span>$m_{prior}$</span>. Therefore, starting close to or at <span>$m_{prior}$</span>, we can use the following quasi-Newton algorithm to find a suitable solution (Tarantola 2005, eq. 3.51):</p><p class="math-container">\[m_{n+1} = m_{n} - \mu_n(G_n^tC_D^{-1}G_n + C_M^{-1})^{-1}(G_n^tC_D^{-1}(y_{calc, n} - y) + C_M^{-1}(m_n - m_{prior}))\]</p><p>where <span>$y_{calc, n}$</span> is the model output at iteration <span>$n$</span> with the set of parameters <span>$m_n$</span>, <span>$(G_n)^i_\alpha = (\frac{g^i}{m^\alpha})_{m_n}$</span> is the matrix of partial derivatives, and <span>$\mu_n$</span> a step size typically lower or equal to 1. In <code>fit_peaks</code>, the two parameters <code>maxiter</code> and <code>relax</code> control the maximum number of iterations <code>n</code> and the step size <span>$\mu_n$</span>, with <span>$\mu_n = \frac{1}{\text{relax}}$</span>.</p><p>The other available method is the Interior Point Newton algorithm from <a href="https://julianlsolvers.github.io/Optim.jl/stable/algo/ipnewton/">Optim.jl</a> (<code>:Optim</code> backend). This method implements an interior-point primal-dual Newton algorithm for solving the nonlinear, constrained optimization problem. In other terms, it allows the use of constraints, such as parameter boundaries. This is the main difference with the quasi-Newton method. The misfit function that is minimized is the <span>$S(m)$</span> function provided above.</p><p>Convergence between the two methods usually is similar, with the quasi-Newton method being slightly faster. However, as there is no boundaries on parameters, one may have problems for instance if the intensity of one peak is close to 0. The quasi-Newton method offers no boundaries for the parameter values, contrary to the Interior Point Newton method. </p><h2 id="Fitting-procedure"><a class="docs-heading-anchor" href="#Fitting-procedure">Fitting procedure</a><a id="Fitting-procedure-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-procedure" title="Permalink"></a></h2><p>A short example probably is better than many worlds. We are going to fit a synthetic signal that we created ourselves with the following code:</p><pre><code class="language-julia hljs">using Plots
using Spectra
using Statistics

# The X axis
x = collect(0:0.2:100)

# The &quot;perfect&quot; Y signal
y_perfect = (
    gaussian(x, [10.0, 35.0, 10.0]) +
    lorentzian(x, [15.0, 55.0, 3.0]) +
    pearson7(x, [20.0, 45.0, 2.0, 0.4])
)
# Of course, in real world we have noise, here it is Gaussian
noise = randn(length(x))*0.3

# This is what we observe and want to fit
y_obs = y_perfect + noise

# Let&#39;s visualize it!
p1 = plot(x, [y_perfect, y_obs]; labels=[&quot;The true signal&quot; &quot;Observations&quot;])</code></pre><p><img src="fit_1.svg" alt/></p><p>First, you define a vector containing named vectors of peak types, <span>$m_{prior}$</span>, <span>$\sigma_{m_{prior}}$</span>, and lower and upper boundaries. For instance, after a visual review of the signal above, you would declare a vector of peak informations like this:</p><pre><code class="language-julia hljs"># (peak_type, m_prior, sigma_m_prior, lower_bounds, upper_bounds)
peaks_info = [
    (
        :gaussian, # peak_type
        [10.5, 30.0, 11.0], # m_prior (intensity, position, hwhm)
        [5.0, 5.0, 3.0], # sigma_m_prior
        [0.0, 0.0, 0.0], # lower_bounds
        [Inf, Inf, 50.0]), # upper_bounds
    (
        :lorentzian, # peak_type
        [17.5, 54.0, 3.1], # m_prior (intensity, position, hwhm)
        [5.0, 3.0, 1.0], # sigma_m_prior
        [0.0, 0.0, 0.0], # lower_bounds
        [Inf, Inf, Inf], # upper_bounds
    ),
    (
        :pearson7, # peak_type
        [21.5, 44.0, 3.0, 0.4], # m_prior (intensity, position, hwhm, shape exponent)
        [3.0, 2.0, 5.0, 0.02], # sigma_m_prior
        [0.0, 0.0, 0.0, 0.0], # lower_bounds
        [100.0, 100.0, 50.0, Inf], # upper_bounds
    ),
]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Tuple{Symbol, Vararg{Vector{Float64}, 4}}}:
 (:gaussian, [10.5, 30.0, 11.0], [5.0, 5.0, 3.0], [0.0, 0.0, 0.0], [Inf, Inf, 50.0])
 (:lorentzian, [17.5, 54.0, 3.1], [5.0, 3.0, 1.0], [0.0, 0.0, 0.0], [Inf, Inf, Inf])
 (:pearson7, [21.5, 44.0, 3.0, 0.4], [3.0, 2.0, 5.0, 0.02], [0.0, 0.0, 0.0, 0.0], [100.0, 100.0, 50.0, Inf])</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Upper and lower boundaries for model parameters are always required when constructing this peaks information vector. However, remember that they are not used in the quasi-Newton method.</p></div></div><p>We then pass the data and this vector of peak informations to <a href="PeakFitting.html#Spectra.prepare_context"><code>prepare_context</code></a> that stores everything in a Julia object. In addition to <code>peaks_info</code>, you will need the data vectors <code>x</code>, <code>y_obs</code>, and the errors on <code>y_obs</code>. Usually we do not have a precise idea of those errors. A good approximation can be provided by the difference between the observed signal and a smoothed version. We adopt this approach here and check if the estimated error makes sens:</p><pre><code class="language-julia hljs">y_smo = smooth(x, y_obs, method=&quot;gcvspline&quot;);
estimated_mean_error = sqrt(mean((y_obs .- y_smo).^2))
println(&quot;The estimated mean standard error on y_obs is $(round(estimated_mean_error,digits=2))&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">The estimated mean standard error on y_obs is 0.25</code></pre><p>OK, the result seems to be not too bad. We will place ourselves in a &quot;real world&quot; situation and  use those errors. For convenience we create an vector of errors</p><pre><code class="language-julia hljs">estimated_error = estimated_mean_error * ones(size(x));</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">501-element Vector{Float64}:
 0.2541910639909907
 0.2541910639909907
 0.2541910639909907
 0.2541910639909907
 0.2541910639909907
 0.2541910639909907
 0.2541910639909907
 0.2541910639909907
 0.2541910639909907
 0.2541910639909907
 ⋮
 0.2541910639909907
 0.2541910639909907
 0.2541910639909907
 0.2541910639909907
 0.2541910639909907
 0.2541910639909907
 0.2541910639909907
 0.2541910639909907
 0.2541910639909907</code></pre><p>We can now pass the data and associated errors to <a href="PeakFitting.html#Spectra.prepare_context"><code>prepare_context</code></a>: </p><pre><code class="language-julia hljs">ctx = prepare_context(x, y_obs, peaks_info, estimated_error)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">FitContext([0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6, 1.8  …  98.2, 98.4, 98.6, 98.8, 99.0, 99.2, 99.4, 99.6, 99.8, 100.0], [1.6088686840357067, 1.1768098635632713, 1.2542895598680681, 1.4549624563172046, 1.1515194775042086, 1.1503532038054318, 0.6433975473731379, 0.9871559991716443, 0.7237932299106741, 0.9477195617366884  …  1.0258099218592251, 0.9362388380003671, 1.0926820748510897, 0.9267941861139594, 0.5242733358386387, 0.5613998542220258, 1.1952521714858138, 0.8508185592348501, 0.3432224544143415, 0.6039496097487248], Tuple[(:gaussian, [10.5, 30.0, 11.0], [5.0, 5.0, 3.0], [0.0, 0.0, 0.0], [Inf, Inf, 50.0]), (:lorentzian, [17.5, 54.0, 3.1], [5.0, 3.0, 1.0], [0.0, 0.0, 0.0], [Inf, Inf, Inf]), (:pearson7, [21.5, 44.0, 3.0, 0.4], [3.0, 2.0, 5.0, 0.02], [0.0, 0.0, 0.0, 0.0], [100.0, 100.0, 50.0, Inf])], [0.2541910639909907, 0.2541910639909907, 0.2541910639909907, 0.2541910639909907, 0.2541910639909907, 0.2541910639909907, 0.2541910639909907, 0.2541910639909907, 0.2541910639909907, 0.2541910639909907  …  0.2541910639909907, 0.2541910639909907, 0.2541910639909907, 0.2541910639909907, 0.2541910639909907, 0.2541910639909907, 0.2541910639909907, 0.2541910639909907, 0.2541910639909907, 0.2541910639909907], [25.0 0.0 … 0.0 0.0; 0.0 25.0 … 0.0 0.0; … ; 0.0 0.0 … 25.0 0.0; 0.0 0.0 … 0.0 0.0004], [0.04 0.0 … 0.0 0.0; 0.0 0.04 … 0.0 0.0; … ; 0.0 0.0 … 0.04 0.0; 0.0 0.0 … 0.0 2500.0], [0.06461309701287192 0.0 … 0.0 0.0; 0.0 0.06461309701287192 … 0.0 0.0; … ; 0.0 0.0 … 0.06461309701287192 0.0; 0.0 0.0 … 0.0 0.06461309701287192], [15.476738404920981 0.0 … 0.0 0.0; 0.0 15.476738404920981 … 0.0 0.0; … ; 0.0 0.0 … 15.476738404920981 0.0; 0.0 0.0 … 0.0 15.476738404920981], Dict{Any, Any}(2 =&gt; 4:6, 3 =&gt; 7:10, 1 =&gt; 1:3), Dict{Symbol, Function}(:pearson7 =&gt; Spectra.pearson7, :lorentzian =&gt; Spectra.lorentzian, :gaussian =&gt; Spectra.gaussian, :pseudovoigt =&gt; Spectra.pseudovoigt), [10.5, 30.0, 11.0, 17.5, 54.0, 3.1, 21.5, 44.0, 3.0, 0.4], [5.0, 5.0, 3.0, 5.0, 3.0, 1.0, 3.0, 2.0, 5.0, 0.02], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [Inf, Inf, 50.0, Inf, Inf, Inf, 100.0, 100.0, 50.0, Inf], Spectra.var&quot;#model#58&quot;{Vector{Float64}, Vector{Tuple{Symbol, Vararg{Vector{Float64}, 4}}}, Dict{Symbol, Function}, Dict{Any, Any}}([0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6, 1.8  …  98.2, 98.4, 98.6, 98.8, 99.0, 99.2, 99.4, 99.6, 99.8, 100.0], [(:gaussian, [10.5, 30.0, 11.0], [5.0, 5.0, 3.0], [0.0, 0.0, 0.0], [Inf, Inf, 50.0]), (:lorentzian, [17.5, 54.0, 3.1], [5.0, 3.0, 1.0], [0.0, 0.0, 0.0], [Inf, Inf, Inf]), (:pearson7, [21.5, 44.0, 3.0, 0.4], [3.0, 2.0, 5.0, 0.02], [0.0, 0.0, 0.0, 0.0], [100.0, 100.0, 50.0, Inf])], Dict{Symbol, Function}(:pearson7 =&gt; Spectra.pearson7, :lorentzian =&gt; Spectra.lorentzian, :gaussian =&gt; Spectra.gaussian, :pseudovoigt =&gt; Spectra.pseudovoigt), Dict{Any, Any}(2 =&gt; 4:6, 3 =&gt; 7:10, 1 =&gt; 1:3)))</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>estimated_error</code> is an positional argument that will be set to an array of 1 if you do not pass a vector. It is advised to pass proper errors for a proper scaling of the misfit function.</p></div></div><p>From there, a good thing is to check that your prior model is not too remote from a good fit. The algorithms we use are local optimization methods and do not aim at finding a global minimum, but only local solutions. If you set <span>$m_{prior}$</span> to values far from the solution, they will fail. To check your starting parameters, we can fit the prior model and the data using:</p><pre><code class="language-julia hljs">p = plot_fit(ctx, title=&quot;Prior model&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">No result provided, plotting the prior...</code></pre><p><img src="fit_2.svg" alt/></p><p>Modify your starting parameters until the model starts to make sense, and then perform a fit calling <a href="PeakFitting.html#Spectra.fit_peaks"><code>fit_peaks</code></a> with your favorite backend. For instance, if you want to use IPNewton, call:</p><pre><code class="language-julia hljs">result = fit_peaks(ctx, backend=:Optim)</code></pre><p>or if you want to use the quasi-Newton method described above, call:</p><pre><code class="language-julia hljs">result = fit_peaks(ctx, backend=:qGN, maxiter=100, relax=5)</code></pre><p><code>result</code> is an object containing:</p><ul><li><code>context::FitContext</code>: Fit context</li><li><code>peak_results::Vector</code>: Peak results</li><li><code>params::Vector{Float64}</code>: Peak parameters with uncertainties</li><li><code>covariance::Matrix{Float64}</code>: Covariance matrix</li><li><code>errors::Vector{Float64}</code>: 1-sigma standard errors on parameters</li><li><code>y_calc::Vector{Float64}</code>: Model predictions</li><li><code>residuals::Vector{Float64}</code>: Residuals</li></ul><p>In <code>result.peal_results</code>, numbers are now Measurements as we use the <a href="https://github.com/JuliaPhysics/Measurements.jl">Measurements.jl</a> library to automatically propagate fitting errors for peak area calculations. </p><p>After a fit, you can print the parameters and peak areas using <a href="PeakFitting.html#Spectra.print_params"><code>print_params</code></a> and plot the fit using <a href="PeakFitting.html#Spectra.plot_fit"><code>plot_fit</code></a>. Let&#39;s do the fit and those steps below</p><pre><code class="language-julia hljs">print_params(result.peak_results)

plot_fit(ctx, result.peak_results)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Peak 1 (gaussian):
  amplitude: 10.024 ± 0.053
  center: 35.026 ± 0.084
  width: 9.977 ± 0.087
  area: 212.9 ± 2.4
Peak 2 (lorentzian):
  amplitude: 14.891 ± 0.078
  center: 55.005 ± 0.017
  width: 3.0 ± 0.027
  area: 140.3 ± 1.2
Peak 3 (pearson7):
  amplitude: 20.1 ± 0.15
  center: 45.007 ± 0.01
  width: 1.973 ± 0.037
  exponent: 0.3955 ± 0.0035
  area: -147.1 ± 9.2</code></pre><p><img src="fit_3.svg" alt/></p><h2 id="Errors-on-peak-parameters"><a class="docs-heading-anchor" href="#Errors-on-peak-parameters">Errors on peak parameters</a><a id="Errors-on-peak-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Errors-on-peak-parameters" title="Permalink"></a></h2><h3 id="Errors-provided-by-fit_peaks"><a class="docs-heading-anchor" href="#Errors-provided-by-fit_peaks">Errors provided by <code>fit_peaks</code></a><a id="Errors-provided-by-fit_peaks-1"></a><a class="docs-heading-anchor-permalink" href="#Errors-provided-by-fit_peaks" title="Permalink"></a></h3><p>The errors provided by <code>fit_peaks</code> come from the evaluation of the Hessian matrix at the optimal point. In the quasi-Newton algorithm, we directly calculate the posterior model covariance matrix as (Tarantola, 2005, eq. 3.53):</p><p class="math-container">\[C_{M, post} = C_{M} - C_{M}G^{t}(G C_M G{t} +C_D)^{-1}G C_M\]</p><p>and retrieve the standard errors on model parameters from the squared root of the diagonal of <span>$C_{M, post}$</span>. In the IPNewton case, we use ForwardDiff.hessian() to calculate the Hessian matrix at the optimal point to optain <span>$C_{M, post}$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Do not neglect off-diagonal terms in <span>$C_{M, post}$</span>. Peak parameters often are strongly correlated, and neglecting off-diagonal terms may lead to report wrong errors on quantities that depends on several peak parameters, such as peak areas. This is why we automatically propagate errors using <span>$C_{M, post}$</span> and Measurements.jl when calculating peak areas in <code>fit_peaks</code> for instance.</p></div></div><h3 id="Checking-errors-with-bootstrapping"><a class="docs-heading-anchor" href="#Checking-errors-with-bootstrapping">Checking errors with bootstrapping</a><a id="Checking-errors-with-bootstrapping-1"></a><a class="docs-heading-anchor-permalink" href="#Checking-errors-with-bootstrapping" title="Permalink"></a></h3><p><span>$C_{M, post}$</span> may not necessarily contain valid parameter uncertainties, particularly if the problem is strongly non-linear.</p><p>To check for parameter errors, one option is to use <a href="https://en.wikipedia.org/wiki/Bootstrapping_(statistics)">bootstrapping</a>. <a href="PeakFitting.html#Spectra.bootstrap"><code>bootstrap</code></a> allows us to bootstrap a spectrum and refit the model on the spectrum subsamples. You will obtain samples of models all adjusted on slightly different data. Using the model samples, we can check that the errors calculated from the Hessian are valid, or if they are not, we can use the new errors calculated from the bootstrap samples.</p><p>The interface is easy, similar to that of <code>fit_peaks</code> but the fit context is defined internally so  you don&#39;t even have to worry about that. For instance, using the quasi-Newton method, we can do: </p><pre><code class="language-julia hljs">boot_params, boot_results = bootstrap(x, y_obs, estimated_error, peaks_info, nb_boot = 50, backend=:Optim);</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The quasi-Newton algorithm is the quickest so you may prefer this one for bootstrapping. If so, you can try also setting maxiter to a value as small as possible without affecting fit convergence. Another tip is to provide a new <code>peaks_info</code> vector with <span>$m_{prior}$</span> set to the values of a good fit that you previously did.</p></div></div><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Here we only used 50 bootstraps for the sake of generating the documentation in a reasonable time. In practice, you should use more bootstraps (e.g. 1000) to get a good estimate of the errors.</p></div></div><p>The <code>bootstrap</code> function returns:</p><ul><li>a matrix of size (<code>nb_params</code>, <code>nb_boot</code>) with the fitted parameters (here <code>boot_params</code>);</li><li>a peak<em>results objects with values tied to their errors thanks to Measurements.jl (here called `boot</em>results`).</li></ul><p>We can now print the bootstrapped results and compare the errors with those previously calculated from the Hessian:</p><pre><code class="language-julia hljs">print_params(boot_results)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Peak 1 (gaussian):
  amplitude: 10.039 ± 0.059
  center: 35.045 ± 0.098
  width: 9.99 ± 0.11
  area: 213.4 ± 3.0
Peak 2 (lorentzian):
  amplitude: 14.91 ± 0.11
  center: 55.009 ± 0.019
  width: 2.994 ± 0.041
  area: 140.2 ± 1.5
Peak 3 (pearson7):
  amplitude: 20.09 ± 0.15
  center: 45.007 ± 0.012
  width: 1.968 ± 0.044
  exponent: 0.3948 ± 0.0037
  area: -145.3 ± 10.0</code></pre><p>OK, actually for this example, we see that the errors from the boostrap analysis are close to those calculated from the Hessian matrix. Everything thus seems OK.</p><p>Of course, a final quick visual inspection is always nice. This can be done by passing the  median of the matrix of bootstrapped parameters to the plot_fit function:</p><pre><code class="language-julia hljs">plot_fit(ctx, boot_results)</code></pre><p><img src="fit_4.svg" alt/></p><h3 id="Bayesian-MCMC-fit-with-Turing.jl"><a class="docs-heading-anchor" href="#Bayesian-MCMC-fit-with-Turing.jl">Bayesian MCMC fit with Turing.jl</a><a id="Bayesian-MCMC-fit-with-Turing.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Bayesian-MCMC-fit-with-Turing.jl" title="Permalink"></a></h3><p>The same problem can be tackled using Turing.jl and the peak shape functions from Spectra as follow.  This offers another way to check that the estimated errors are good for instance, or to use different types of  prior probability distributions on model parameters (as in the quasi-Newton we assume Gaussian priors).</p><p>You will need to install Turing.jl, which is not a dependency of Spectra.  The code below runs well but it may not be fully optimized. It is just for the sack of example. </p><p>Run it on your own computer! If you have suggestions, do not hesitate!</p><pre><code class="language-julia hljs">using Turing

# Define a Bayesian model with priors
@model function bayesian_peaks(x, y)
    # Define priors based on peak_types

    # PEAK 1
    amplitude ~ truncated(Normal(10.016, 0.5), 0.0, Inf)
    center ~ Normal(34.92, 0.5)
    width ~ truncated(Normal(10.0, 0.5), 0.0, Inf)

    μ = gaussian(x, [amplitude, center, width])
    
    # PEAK 2
    amplitude2 ~ truncated(Normal(14.9, 0.5), 0.0, Inf)
    center2 ~ Normal(55.0, 0.5)
    width2 ~ truncated(Normal(3.0, 0.5), 0.0, Inf)
    
    μ2 = lorentzian(x, [amplitude2, center2, width2])
    
    # PEAK 3
    amplitude3 ~ truncated(Normal(25.5, 0.5), 0.0, Inf)
    center3 ~ Normal(43.0, 10.0)
    width3 ~ truncated(Normal(2.0, 0.5), 0.0, Inf)
    lr ~ truncated(Normal(0.39, 0.03), 0.0, 1.0)
    
    # Calculate model prediction
    μ3 = pseudovoigt(x, [amplitude3, center3, width3, lr])
    
    # Likelihood
    σ ~ truncated(Normal(0.2, 0.03), 0.001, Inf)
    y ~ MvNormal(μ + μ2 + μ3, σ^2 * I)
end

chain = sample(bayesian_peaks(x_fit, y_fit), NUTS(), 2000, nchains=3, progress=true)</code></pre><h2 id="Final-remarks"><a class="docs-heading-anchor" href="#Final-remarks">Final remarks</a><a id="Final-remarks-1"></a><a class="docs-heading-anchor-permalink" href="#Final-remarks" title="Permalink"></a></h2><p>Done, please do check the examples in the Tutorials section for further peak fitting examples. Below you will find the full API of the various functions, including peak shapes, area calculations, fitting algorithms...</p><h2 id="Functions-API"><a class="docs-heading-anchor" href="#Functions-API">Functions API</a><a id="Functions-API-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-API" title="Permalink"></a></h2><h3 id="Peak-fitting-2"><a class="docs-heading-anchor" href="#Peak-fitting-2">Peak fitting</a><a class="docs-heading-anchor-permalink" href="#Peak-fitting-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.prepare_context" href="#Spectra.prepare_context"><code>Spectra.prepare_context</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prepare_context(x, y, peaks_info, sigma=ones(length(x)))</code></pre><p>Create a precomputed context for peak fitting operations.</p><p><strong>Arguments</strong></p><ul><li><code>x::Vector{Float64}</code>: Independent variable values</li><li><code>y::Vector{Float64}</code>: Observations</li><li><code>peaks_info::Vector{Tuple}</code>: Peak specifications containing:<ul><li><code>Symbol</code>: Peak type (<code>:gaussian</code>, <code>:lorentzian</code>, <code>:pseudovoigt</code>, <code>:pearson7</code>)</li><li><code>Vector{Float64}</code>: Initial parameters</li><li><code>Vector{Float64}</code>: Parameter uncertainties</li><li><code>Vector{Float64}</code>: Lower bounds</li><li><code>Vector{Float64}</code>: Upper bounds</li></ul></li><li><code>sigma::Vector{Float64}</code>: Data uncertainties (default: ones)</li></ul><p><strong>Returns</strong></p><ul><li><code>FitContext</code>: Precomputed structure containing matrices, indices, and model function</li></ul><p><strong>Examples</strong></p><p>&#39;&#39;&#39;julia peaks<em>info = [ (:gaussian, [1.0, 0.0, 0.5], [0.1, 0.05, 0.1], [-Inf, -1.0, 0.1], [Inf, 1.0, 2.0]), (:lorentzian, [0.5, 0.2, 0.3], [0.1, 0.05, 0.1], [0.0, -0.5, 0.1], [2.0, 0.5, 1.0]) ] ctx = prepare</em>context(x, peaks_info, sigma) &#39;&#39;&#39;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/fitting.jl#L56-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.fit_peaks" href="#Spectra.fit_peaks"><code>Spectra.fit_peaks</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fit_peaks(ctx::FitContext; backend=:qGN, relax=4, maxiter=100)</code></pre><p>Perform peak fitting using specified optimization backend.</p><p><strong>Arguments</strong></p><ul><li><code>ctx::FitContext</code>: Precomputed context from <code>prepare_context</code></li><li><code>backend::Symbol</code>: Optimization method (<code>:Optim</code> or <code>:qGN</code>)</li><li><code>relax::Real</code>: Step relaxation factor (qGN only)</li><li><code>maxiter::Int</code>: Maximum iterations (qGN only)</li></ul><p><strong>Returns</strong></p><ul><li><code>FitResult</code>: Structured results containing:<ul><li><code>context::FitContext</code>: Fit context</li><li><code>peak_results::Vector</code>: Peak results with uncertainties</li><li><code>params::Vector{Float64}</code>: Peak parameters</li><li><code>covariance::Matrix{Float64}</code>: Covariance matrix</li><li><code>errors::Vector{Float64}</code>: 1-sigma standard errors on parameters</li><li><code>y_calc::Vector{Float64}</code>: Model predictions</li><li><code>residuals::Vector{Float64}</code>: Residuals</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">x = 1:1.0:100
y = gaussian(x, 1., 50.0, 5.0) .+ 0.1 * randn(length(x))
peaks_info = [
    (:gaussian, [1.0, 50.0, 5.0], [0.1, 0.05, 0.1], [0.0, 40.0, 0.1], [2.0, 60.0, 10.0])
]
ctx = prepare_context(x, y, peaks_info)
result = fit_peaks(ctx; backend=:qGN, relax=4, maxiter=100)
plot_fit(ctx; result=result.peak_results)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/fitting.jl#L133-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.fit_Optim" href="#Spectra.fit_Optim"><code>Spectra.fit_Optim</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fit_Optim(ctx::FitContext)</code></pre><p>Perform a box constrained fit using the Optim package with the LBFGS algorithm.</p><p>The loss function combines a loss on data and on model prior (eq. 3.46 in Tarantola 2005)</p><p><strong>Arguments</strong></p><p>-<code>ctx</code>: context created by <code>prepare_context</code></p><p><strong>Returns</strong></p><ul><li><code>fitted_params</code>: fitted parameters</li><li><code>CMpost</code>: covariance matrix of the fitted parameters</li><li><code>sqrt.(diag(CMpost))</code>: errors of the fitted parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/fitting.jl#L188-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.fit_qNewton" href="#Spectra.fit_qNewton"><code>Spectra.fit_qNewton</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fit_qNewton(ctx::FitContext; maxiter=100, relax=5)</code></pre><p>Perform a quasi-Newton fit (Tarantola 2005, eq. 3.51)</p><p><strong>Arguments</strong></p><p>-<code>ctx</code>: context created by <code>prepare_context</code> -<code>maxiter</code>: maximum number of iterations -<code>relax</code>: relaxation factor for the step size</p><p><strong>Returns</strong></p><ul><li><code>mcurrent</code>: fitted parameters</li><li><code>CMpost</code>: covariance matrix of the fitted parameters</li><li><code>sqrt.(diag(CMpost))</code>: errors of the fitted parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/fitting.jl#L241-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.plot_fit" href="#Spectra.plot_fit"><code>Spectra.plot_fit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_fit(ctx, peak_results=nothing; xlabel=&quot;X&quot;, ylabel=&quot;Y&quot;, title=&quot;Model adjustement&quot;)</code></pre><p>return a plot of the data and the fit given a <code>ctx</code> context created by <code>prepare_context</code>,  and a <code>result</code> generated by <code>fit_peaks</code> or <code>get_fit_results</code>. If result is not provided, the prior is plotted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/fitting.jl#L277-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.print_params" href="#Spectra.print_params"><code>Spectra.print_params</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">print_params(peak_results)</code></pre><p>print the parameters after the fit, peak<em>results is a vector of Named Tuples      (generated by get</em>peak_results) with the results of the fit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/fitting.jl#L324-L329">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.get_peak_results" href="#Spectra.get_peak_results"><code>Spectra.get_peak_results</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_peak_results(ctx, params, CMpost)</code></pre><p>Returns a vector of Named Tuples with the results of the fit.  Values are tied to their errors via the covariance matrix CMpost.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/fitting.jl#L349-L355">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.bootstrap" href="#Spectra.bootstrap"><code>Spectra.bootstrap</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bootstrap(x, y, sigma, peaks_info; nb_boot = 100, backend=:qGN, relax=5., maxiter=100)</code></pre><p>Perform a bootstrap on the fit.</p><p><strong>Arguments</strong></p><p>-<code>x</code>: x-axis data -<code>y</code>: y-axis data -<code>sigma</code>: data noise -<code>peaks_info</code>: vector of tuples with the peak type and parameters     (peak<em>type, initial</em>params, uncertainties, lower<em>bounds, upper</em>bounds) -<code>nb_boot</code>: number of bootstrap samples -<code>backend</code>: optimization backend, either :Optim or :qGN -<code>relax</code>: relaxation factor for the step size (only used in :qGN) -<code>maxiter</code>: maximum number of iterations (only used in :qGN)</p><p><strong>Returns</strong></p><ul><li>a matrix of size (number of parameters, number of bootstrap samples) with the fitted parameters</li><li>a vector of Named Tuples with the results of the fit. Values are tied to their errors via the covariance matrix CMpost.   (peak<em>type, initial</em>params, uncertainties, lower<em>bounds, upper</em>bounds)  </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/fitting.jl#L393-L413">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.FitContext" href="#Spectra.FitContext"><code>Spectra.FitContext</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>FitContext type containing all fitting context -<code>x::Vector{Float64}</code>: x data vector. -<code>y::Vector{Float64}</code>: y data vector. -<code>peaks_info::Vector{Tuple}</code>: contains the informations of the peaks of the model. -<code>sigma::Vector{Float64}</code>: error on y. -<code>CD::Matrix{Float64}</code>: data covariance matrix. -<code>ICD::Matrix{Float64}</code>: inverse of the data covariance matrix. -<code>mprior::Vector{Float64}</code>: prior model parameters. -<code>mprior_sigma::Vector{Float64}</code>: uncertainties on prior model parameters. -<code>CM::Matrix{Float64}</code>: model covariance matrix (prior). -<code>ICM::Matrix{Float64}</code>: inverse of the model covariance matrix (prior). -<code>all_lower_bounds::Vector{Float64}</code>: lower boundaries for parameters. -<code>all_upper_bounds::Vector{Float64}</code>: upper boundaries for parameters. -<code>model::Function</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/fitting.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.FitResult" href="#Spectra.FitResult"><code>Spectra.FitResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>FitResult type containing all fitting results and metadata <code>context::FitContext</code>: Fit Context. <code>peak_results::Vector</code>: Vector of Named Tuples containing parameters and areas for each peak, with errors. <code>params::Vector{Float64}</code>: Vector of parameters. <code>covariance::Matrix{Float64}</code>: Covariance matrix at the optimal point <span>$C_{M, post}$</span>. <code>errors::Vector{Float64}</code>: Uncertainties on parameters calculated as <span>$sqrt.(diag(covariance))$</span>. <code>y_calc::Vector{Float64}</code>: Calculated y values, using <code>params</code>. <code>residuals::Vector{Float64}</code>: Difference between calculated and input y values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/fitting.jl#L35-L44">source</a></section></article><h3 id="Peak-shapes"><a class="docs-heading-anchor" href="#Peak-shapes">Peak shapes</a><a id="Peak-shapes-1"></a><a class="docs-heading-anchor-permalink" href="#Peak-shapes" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.create_peaks" href="#Spectra.create_peaks"><code>Spectra.create_peaks</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_peaks(x::Vector{Float64}, peak_infos::Vector{Dict{Symbol,Any}})</code></pre><p>Generate multiple peaks and their sum from a collection of peak descriptions.</p><p><strong>Arguments</strong></p><ul><li><code>x::Vector{Float64}</code>: X-axis values where peaks will be evaluated.</li><li><code>peak_infos::Vector{Dict}</code>: List of dictionaries describing peaks. Each dictionary should contain:<ul><li><code>:type</code>: Peak type (<code>:gaussian</code>, <code>:lorentzian</code>, <code>:pseudovoigt</code>, <code>:pearson7</code>)</li><li>Required parameters for the specified peak type:<ul><li>Gaussian: <code>:amplitude</code>, <code>:center</code>, <code>:hwhm</code></li><li>Lorentzian: <code>:amplitude</code>, <code>:center</code>, <code>:hwhm</code></li><li>PseudoVoigt: <code>:amplitude</code>, <code>:center</code>, <code>:hwhm</code>, <code>:lorentzian_fraction</code></li><li>Pearson7: <code>:amplitude</code>, <code>:center</code>, <code>:hwhm</code>, <code>:exponent</code></li></ul></li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>peaks::Matrix{Float64}</code>: Matrix where each column represents a individual peak</li><li><code>total_spectrum::Vector{Float64}</code>: Sum of all peaks</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">x = collect(0:0.1:10)
peak_infos = [
Dict(:type =&gt; :gaussian, :amplitude =&gt; 1.0, :center =&gt; 5.0, :hwhm =&gt; 0.5),
Dict(:type =&gt; :lorentzian, :amplitude =&gt; 0.8, :center =&gt; 7.0, :hwhm =&gt; 1.2),
Dict(:type =&gt; :pearson7, :amplitude =&gt; 0.8, :center =&gt; 3.0, :hwhm =&gt; 0.2, :exponent =&gt; 1.9)
]
peaks, total = create_peaks(x, peak_infos)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/functions.jl#L112-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.gaussian" href="#Spectra.gaussian"><code>Spectra.gaussian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gaussian(x, amplitude, center, hwhm)
gaussian(x, p)</code></pre><p>Gaussian function with parameters amplitude, center, hwhm or a vector p = [amplitude, center, hwhm].</p><p><strong>Notes:</strong></p><ul><li>the half-width at half maximum (hwhm) of the gaussian peak is related to the standard deviation sigma by: hwhm = sqrt(2*log(2)) * sigma</li><li>gaussian(x, p) is a shorthand for gaussian(x, p[1], p[2], p[3])</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/functions.jl#L30-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.lorentzian" href="#Spectra.lorentzian"><code>Spectra.lorentzian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lorentzian(x, amplitude, center, hwhm)
lorentzian(x, p)</code></pre><p>Lorentzian function with parameters amplitude, center, hwhm or a vector p = [amplitude, center, hwhm].</p><p><strong>Notes:</strong></p><ul><li>hwhm: half-width at half maximum</li><li>lorentzian(x, p) is a shorthand for lorentzian(x, p[1], p[2], p[3])</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/functions.jl#L50-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.pseudovoigt" href="#Spectra.pseudovoigt"><code>Spectra.pseudovoigt</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pseudovoigt(x, amplitude, center, hwhm, lorentzian_fraction)
pseudovoigt(x, p)</code></pre><p>Pseudovoigt function with parameters amplitude, center, hwhm, lorentzian<em>fraction or a vector p = [amplitude, center, hwhm, lorentzian</em>fraction].</p><p><strong>Notes:</strong></p><ul><li>hwhm: half-width at half maximum.</li><li>pseudovoigt(x, p) is a shorthand for lorentzian(x, p[1], p[2], p[3], p[4]).</li><li>calculated as lorentzian<em>fraction*lorentzian + (1 - lorentzian</em>fraction)*gaussian.</li><li>lorentzian_fraction is a value between 0 and 1 that controls the mixing between Gaussian and Lorentzian.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/functions.jl#L71-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.pearson7" href="#Spectra.pearson7"><code>Spectra.pearson7</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pearson7(x, amplitude, center, hwhm, exponent)
pearson7(x, p)</code></pre><p>Pearson 7 function with parameters amplitude, center, hwhm, exponent or a vector p = [amplitude, center, hwhm, exponent].</p><p><strong>Notes:</strong></p><ul><li>Equation is amplitude / (1 + ((x - center)/hwhm)^2 * (2^(1/exponent) - 1))^exponent.</li><li>pearson7(x, p) is a shorthand for pearson7(x, p[1], p[2], p[3], p[4]).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/functions.jl#L93-L102">source</a></section></article><h3 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.area_peaks" href="#Spectra.area_peaks"><code>Spectra.area_peaks</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">area_peaks(peak_type::Symbol, amplitude::Float64, hwhm::Float64; lorentzian_fraction=nothing, exponent=nothing)</code></pre><p>Calculate the area under Gaussian, Lorentzian, Pseudo-Voigt, or Pearson VII peaks based on their parameters. Areas are calculated using analytical formulas.</p><p><strong>Arguments</strong></p><ul><li><code>peak_type::Symbol</code>: The type of peak. Supported types are:<ul><li><code>:gaussian</code>: Gaussian peak.</li><li><code>:lorentzian</code>: Lorentzian peak.</li><li><code>:pseudovoigt</code>: Pseudo-Voigt peak (weighted combination of Gaussian and Lorentzian).</li><li><code>:pearson7</code>: Pearson VII peak.</li></ul></li><li><code>amplitude::Float64</code>: Amplitude of the peak (maximum height).</li><li><code>hwhm::Float64</code>: Half-width at half-maximum of the peak.</li><li><code>lorentzian_fraction::Union{Float64, Nothing}</code>: Lorentzian fraction (for Pseudo-Voigt peaks). Must be in [0, 1]. Default is <code>nothing</code>.</li><li><code>exponent::Union{Float64, Nothing}</code>: Shape parameter for Pearson VII peaks. Default is <code>nothing</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>area::Float64</code>: The calculated area under the specified peak.</li></ul><p><strong>Examples</strong></p><p><strong>Gaussian Peak</strong></p><pre><code class="language-julia hljs">A = 2.0
hwhm = 0.5
area_gaussian = peak_area(&quot;gaussian&quot;, amplitude=A, hwhm=hwhm)</code></pre><p><strong>Lorentzian Peak</strong></p><pre><code class="language-julia hljs">A = 2.0
hwhm = 0.5
area_lorentzian = peak_area(&quot;lorentzian&quot;, amplitude=A, hwhm=hwhm)</code></pre><p><strong>Pseudo-Voigt Peak</strong></p><pre><code class="language-julia hljs">A = 2.0
hwhm = 0.5
lorentzian_fraction = 0.5
area_pseudovoigt = peak_area(&quot;pseudovoigt&quot;, amplitude=A, hwhm=hwhm, lorentzian_fraction=lorentzian_fraction)</code></pre><p><strong>Pearson VII Peak</strong></p><pre><code class="language-julia hljs">A = 2.0
hwhm = 0.5
exponent = 2.0
area_pearson7 = peak_area(&quot;pearson7&quot;, amplitude=A, hwhm=hwhm, exponent=exponent)</code></pre><p><strong>Notes</strong></p><ol><li><strong>Gaussian Formula</strong>:  <span>$\text{Area} = A \cdot \text{hwhm} \cdot \sqrt{\frac{\pi}{\ln 2}}$</span></li><li><strong>Lorentzian Formula</strong>:  <span>$\text{Area} = \pi \cdot A \cdot \text{hwhm}$</span></li><li><strong>Pseudo-Voigt Formula</strong>:  <span>$\text{Area} = \eta \cdot (\pi \cdot A \cdot \text{hwhm}) + (1-\eta) \cdot (A \cdot \text{hwhm} \cdot \sqrt{\frac{\pi}{\ln 2}})$</span></li><li><strong>Pearson VII Formula</strong>:  <span>$\text{Area} = A \cdot \text{hwhm} \cdot \sqrt{\frac{\pi}{2^{1/exponent} - 1}} \cdot \frac{\Gamma(exponent - 0.5)}{\Gamma(exponent)}$</span></li></ol><p><strong>Errors</strong></p><ul><li>Throws an error if an unsupported <code>peak_type</code> is provided.</li><li>Throws an error if required parameters for a specific peak type are not provided.</li><li>Throws an error if lorentzian_fraction is not comprised in the [0, 1] interval</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/peakmeasurement.jl#L323-L383">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Spectra.bootsample" href="#Spectra.bootsample"><code>Spectra.bootsample</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bootsample(x, y; boottype::String=&quot;np&quot;, ese=nothing)</code></pre><p><strong>Inputs</strong></p><ul><li><code>x</code>: the x axis. It can have multiple columns.</li><li><code>y</code>: the y axis. It can have multiple columns.</li></ul><p><strong>Options</strong></p><ul><li><code>boottype::String = &quot;np&quot;</code>: type of bootstrapping<ul><li>&quot;np&quot;: non-parametric bootstrapping. Data resampled with replacement. </li><li>&quot;p&quot;: parametric bootstrapping. Data resampled from the Normal(y, ese) distribution.</li></ul></li><li><code>ese = nothing</code>: standard errors on <code>y</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>b_x_f</code>: bootstrapped x sample</li><li><code>b_y_f</code>: bootstrapped y sample</li></ul><p>The bootstrap function can be embedded in a for loop, and will each time produce a different dataset. Performing K times the bootstrapping and fitting each time the model will allow to estimate the error distribution on the peak parameters. This technic has the advantage of making no prior assumption on the probability distribution functions of parameters errors. However, it is more time consuming that using the covariance matrix.</p><p><strong>References</strong></p><ul><li>Efron, B. 1979. “Bootstrap Methods: Another Look at the Jackknife.” The Annals of Statistics 7 (1): 1–26.</li><li>Efron, Bradley. 1981. “Nonparametric Estimates of Standard Error: The Jackknife, the Bootstrap and Other Methods.” Biometrika 68 (3): 589–99. doi:10.1093/biomet/68.3.589.</li><li>Efron, B., and Tibshirani, R. 1994. An Introduction to the Bootstrap. CRC press.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/f521f5c658af446dfbd2ce68f38d41df15603d9a/src/bootstrap.jl#L17-L41">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="Measurements.html">« Measurements</a><a class="docs-footer-nextpage" href="MachineLearning.html">Machine Learning »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Saturday 3 May 2025 21:02">Saturday 3 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
