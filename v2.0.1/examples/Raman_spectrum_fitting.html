<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Peak fitting the Raman spectrum of a glass · Spectra documentation</title><meta name="title" content="Peak fitting the Raman spectrum of a glass · Spectra documentation"/><meta property="og:title" content="Peak fitting the Raman spectrum of a glass · Spectra documentation"/><meta property="twitter:title" content="Peak fitting the Raman spectrum of a glass · Spectra documentation"/><meta name="description" content="Documentation for Spectra documentation."/><meta property="og:description" content="Documentation for Spectra documentation."/><meta property="twitter:description" content="Documentation for Spectra documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Spectra documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Welcome to Spectra&#39;s documentation!</a></li><li><span class="tocitem">User manual</span><ul><li><a class="tocitem" href="../PreProcessing.html">Data Processing</a></li><li><a class="tocitem" href="../Measurements.html">Measurements</a></li><li><a class="tocitem" href="../PeakFitting.html">Peak fitting</a></li><li><a class="tocitem" href="../MachineLearning.html">Machine Learning</a></li><li><a class="tocitem" href="../HelperFunctions.html">Helper Functions</a></li><li><a class="tocitem" href="../Tips.html">Tips</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="Baseline_examples.html">Baseline examples</a></li><li><a class="tocitem" href="Full_processing.html">Processing data</a></li><li class="is-active"><a class="tocitem" href="Raman_spectrum_fitting.html">Peak fitting the Raman spectrum of a glass</a><ul class="internal"><li><a class="tocitem" href="#Context"><span>Context</span></a></li><li><a class="tocitem" href="#Importing-libraries-and-data"><span>Importing libraries and data</span></a></li><li><a class="tocitem" href="#Importing-data"><span>Importing data</span></a></li><li><a class="tocitem" href="#Baseline-Removal"><span>Baseline Removal</span></a></li><li><a class="tocitem" href="#Signal-extraction-and-normalisation"><span>Signal extraction and normalisation</span></a></li><li><a class="tocitem" href="#Fitting-the-spectrum"><span>Fitting the spectrum</span></a></li><li><a class="tocitem" href="#Checking-errors-with-bootstrapping"><span>Checking errors with bootstrapping</span></a></li></ul></li><li><a class="tocitem" href="Smoothing.html">Smoothing data</a></li></ul></li><li><a class="tocitem" href="../References.html">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href="Raman_spectrum_fitting.html">Peak fitting the Raman spectrum of a glass</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Raman_spectrum_fitting.html">Peak fitting the Raman spectrum of a glass</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/charlesll/Spectra.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/charlesll/Spectra.jl/blob/master/examples/Raman_spectrum_fitting.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><p>The source files for all examples can be found in <a href="https://github.com/charlesll/Spectra.jl/tree/master/examples/">/examples</a>.</p><h1 id="Peak-fitting-the-Raman-spectrum-of-a-glass"><a class="docs-heading-anchor" href="#Peak-fitting-the-Raman-spectrum-of-a-glass">Peak fitting the Raman spectrum of a glass</a><a id="Peak-fitting-the-Raman-spectrum-of-a-glass-1"></a><a class="docs-heading-anchor-permalink" href="#Peak-fitting-the-Raman-spectrum-of-a-glass" title="Permalink"></a></h1><p>Code by Charles Le Losq, Created 7 April 2015 for Python, Modified 30 Sept. 2016 for Julia, updated February 2019, then April 2025.</p><p>Last modified: April 2025 for release of Spectra v2.0.0.</p><p>Glass materials usually present broad bands due to their inherent structural disorder. Due to this, peak-fitting Raman spectra of glasses is informative but difficult, and requires a careful balance between model freedom and constraints. Using boundaries for parameters can help, as well as setting priors on model parameters and working in a Bayesian framework. Spectra provides a function to do such things, <code>fit_peaks</code>.</p><p>Here, we will fit a Raman spectrum of a glass with Julia, using the <code>fit_peaks</code> function now available in Spectra. We will leverage the quasi-Newton method, with a loss function that takes into account data and prior model errors. In other terms, we are setting ourselves in a Bayesian framework, with priors on the model parameters.</p><p>You could solve the following problem in a pure Bayesian approach, using e.g. HMC algorithm in Turing.jl. However, it takes some time... The quasi-Newton method is clean, the Julia code is the direct transcription of the mathematical formulas available in Tarantola (<a href="https://epubs.siam.org/doi/book/10.1137/1.9780898717921">2005</a>), chapter 3. This method is fast, accurate, but sometimes a bit instable. You can also use the Interior Point Newton algorithm from Optim.jl, by setting the backend to <code>:Optim</code>. It is good, stable but slightly slower. It also benefits from boundaries!</p><h2 id="Context"><a class="docs-heading-anchor" href="#Context">Context</a><a id="Context-1"></a><a class="docs-heading-anchor-permalink" href="#Context" title="Permalink"></a></h2><p>In this example, we fit the 850-1300 cm<span>$^{-1}$</span> portion of a Raman spectrum of a lithium tetrasilicate glass Li<span>$_2$</span>Si<span>$_4$</span>O<span>$_9$</span>, the name will be abbreviated LS4 in the following.</p><p>For further references for fitting Raman spectra of glasses, please see for instance:</p><ul><li>Virgo et al., 1980, Science 208, p 1371-1373;</li><li>Mysen et al., 1982, American Mineralogist 67, p 686-695;</li><li>McMillan, 1984, American Mineralogist 69, p 622-644; Mysen, 1990, American Mineralogist 75, p 120-134;</li><li>Le Losq et al., 2014, Geochimica et Cosmochimica Acta 126, p 495-517</li><li>Le Losq et al., 2015, Progress in Earth and Planetary Sciences 2:22.</li></ul><p><code>fit_peaks</code> is meant to fit a single spectrum. You could do a loop to fit several spectra, but if you want to define global models, I invite you to use the <a href="https://jump.dev/">JuMP framework</a> or, if you fancy Bayesian MCMC methods, <a href="https://turinglang.org/index.html">Turing.jl</a></p><h2 id="Importing-libraries-and-data"><a class="docs-heading-anchor" href="#Importing-libraries-and-data">Importing libraries and data</a><a id="Importing-libraries-and-data-1"></a><a class="docs-heading-anchor-permalink" href="#Importing-libraries-and-data" title="Permalink"></a></h2><p>First, we import the libraries for doing various things:</p><pre><code class="language-julia hljs">using Spectra ## our Spectra library
using Statistics ## to have access to core functions like mean() or std()
using DelimitedFiles ## to import the data

# Plotting libraries
using Plots ## to make plots
gr() ## Plots backend
using LaTeXStrings ## LaTeX for superscripts/subscripts in labels, captions...</code></pre><h2 id="Importing-data"><a class="docs-heading-anchor" href="#Importing-data">Importing data</a><a id="Importing-data-1"></a><a class="docs-heading-anchor-permalink" href="#Importing-data" title="Permalink"></a></h2><p>For that, we use readdlm from DelimitedFiles.</p><pre><code class="language-julia hljs"># get the spectrum, with skipping header and footer comment lines from the spectrometer
data = readdlm(joinpath(@__DIR__, &quot;data/LS4.txt&quot;), &#39;\t&#39;, Float64)

# To skip header and footer lines
skip_header = 23
skip_footer = 121
inputsp = zeros(size(data)[1]-skip_header-skip_footer,2)
j = 1
for i = skip_header+1:size(data)[1]-skip_footer
    inputsp[j,1] = Float64(data[i,1])
    inputsp[j,2] = Float64(data[i,2])
    global j += 1
end</code></pre><p>We will now make the following pre-processing: we correct the data from temperature and excitation line effects using the <code>tlcorrection</code> function. It is not always necessary at frequencies &gt; 500 cm-1, but this is just for the sack of example in the present case</p><pre><code class="language-julia hljs">x, y, ese_y = tlcorrection(inputsp, 23.0, 490.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([584.8513, 585.0513, 585.2513, 585.4513, 585.6513, 585.8513, 586.0513, 586.2513, 586.4513, 586.6513  …  1351.6512, 1351.8513, 1352.0513, 1352.2513, 1352.4513, 1352.6512, 1352.8513, 1353.0513, 1353.2513, 1353.4513], [0.002152145651254479, 0.002149300613068526, 0.0021457338996192315, 0.0021417631435398624, 0.002137780663110672, 0.002134364858870799, 0.0021321099907604564, 0.002131641055113538, 0.0021333985152228083, 0.0021368058863904253  …  0.00040897094350943604, 0.0004082655479337475, 0.0004084222446453181, 0.00040902726920146295, 0.0004096665011636359, 0.0004101231280126589, 0.0004104694406433908, 0.000410805190987191, 0.00041121122445985416, 0.00041167269199465984], [1.2619050364402098e-5, 1.261349674616636e-5, 1.2605813720811051e-5, 1.259692870090874e-5, 1.258799266954953e-5, 1.2580710236994312e-5, 1.2576839314553725e-5, 1.2578231688318044e-5, 1.2586191928015794e-5, 1.2599016849624009e-5  …  9.31882014197006e-6, 9.311671180523136e-6, 9.314348759429777e-6, 9.32213663503718e-6, 9.330310260683871e-6, 9.33640087203318e-6, 9.341235304943654e-6, 9.345948214828419e-6, 9.351459470661644e-6, 9.357599356847322e-6])</code></pre><p>and now we create a new plot for showing the spectrum</p><pre><code class="language-julia hljs">plot(x, y,
xlabel=L&quot;Raman shift, cm$^{-1}$&quot;,
ylabel=&quot;Normalized intensity, a. u.&quot;,
title=&quot;Figure 1: the spectrum of interest&quot;)</code></pre><p><img src="rsf_1.svg" alt/></p><p>So we are looking at the 500-1300 cm<span>$^{-1}$</span> portion of the Raman spectrum of the glass. We see a peak near 800 cm<span>$^{-1}$</span>, and two others near 950 and 1085 cm<span>$^{-1}$</span>. We will be interested in fitting the 870-1300 cm<span>$^{-1}$</span> portion of this spectrum, which can be assigned to the various symmetric and assymetric stretching vibrations of Si-O bonds in the SiO<span>$_2$</span> tetrahedra present in the glass network (see the above cited litterature for details).</p><h2 id="Baseline-Removal"><a class="docs-heading-anchor" href="#Baseline-Removal">Baseline Removal</a><a id="Baseline-Removal-1"></a><a class="docs-heading-anchor-permalink" href="#Baseline-Removal" title="Permalink"></a></h2><p>First thing we notice in Fig. 1, we have to remove a baseline because this spectrum is shifted from 0 by some &quot;background&quot; scattering. This quite typical in Raman spectra of glasses. Several ways exist to do so. We&#39;re going to the simplest thing: a polynomial fitting the signal base around 870 and 1300 cm<span>$^{-1}$</span>. Other reasonnable solutions include a linear function, and a constant function. The two latter can be fitted between 1300 and 1350 cm<span>$^{-1}$</span>, but we will need to add another peak around 800 cm<span>$^{-1}$</span>. For now, the example is done with fitting the 870 cm<span>$^{-1}$</span> portion of spectra, as this usually results in more robust final results.</p><p>First, we define the regions of interest roi where we think the baseline is:</p><pre><code class="language-julia hljs">roi = [860.0 870.0; 1300.0 1400.0]

# We now call the `baseline` function to define the baseline and subtract it from `y`:
y_corr, y_bas = baseline(x, y, roi=roi, method=&quot;polynomial&quot;, polynomial_order=2)

# To visualize this, we create a plot showing the baseline:
plot(x, [y y_corr y_bas],
xlabel=L&quot;Raman shift, cm$^{-1}$&quot;,
ylabel=&quot;Normalized intensity, a. u.&quot;,
title=&quot;Figure 2: the fit of the background&quot;)</code></pre><p><img src="rsf_2.svg" alt/></p><h2 id="Signal-extraction-and-normalisation"><a class="docs-heading-anchor" href="#Signal-extraction-and-normalisation">Signal extraction and normalisation</a><a id="Signal-extraction-and-normalisation-1"></a><a class="docs-heading-anchor-permalink" href="#Signal-extraction-and-normalisation" title="Permalink"></a></h2><p>Now we will get the portion of the spectrum we want to fit using <code>extract_signal</code>. Then we normalise the signal using <code>normalise</code>. We will calculate the errors based on the comparison between the signal and its &quot;smoothed version&quot;, provided by <code>smooth</code>.</p><pre><code class="language-julia hljs"># First we extract the signal we want to fit
x_fit, y_fit, _ = extract_signal(x, y_corr, [860. 1300.])

# We normalise y_fit so that its area is 1
y_fit = normalise(y_fit; x=x_fit, method=&quot;area&quot;)

# We smoothed the signal and get an estimate of the errors using it.
y_fit_perfect = smooth(x_fit, y_fit, method=&quot;whittaker&quot;, lambda=1e2)
ese_y_fit = sqrt.(mean((y_fit_perfect-y_fit).^2)) * ones(size(y_fit_perfect))

# Let&#39;s have a look at the signal in the fitting region
plot(x_fit, y_fit, label=&quot;Signal to fit&quot;)
plot!(x_fit, y_fit_perfect, label=&quot;smoothed&quot;,
    xlabel=L&quot;Raman shift, cm$^{-1}$&quot;,
    ylabel=&quot;Normalized intensity, a. u.&quot;,
    title=&quot;Figure 3: signal to peak fit&quot;)</code></pre><p><img src="rsf_3.svg" alt/></p><h2 id="Fitting-the-spectrum"><a class="docs-heading-anchor" href="#Fitting-the-spectrum">Fitting the spectrum</a><a id="Fitting-the-spectrum-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-the-spectrum" title="Permalink"></a></h2><p>We do the fit using the <code>fit_peaks</code> function with the quasi-Newton algorithm. From the litterature, we have five peaks (see Le Losq et al. 2014, 2015 and references therein). Compared to earlier studies, we also now know that the main one near 1080 cm<span>$^-1$</span> may be actually a pseudovoigt peak.</p><p>Here we will place a strong prior on the intensity of the peak near 1090 cm<span>$^-1$</span>. It seems even a bit unrealistic but the influence of the prior loss compared to the data loss is somehow small, so if you want to add tight constraints you sometime need to place low uncertainties on the prior values of the parameters you want to constrain. Here we assume that the central band should be fit by a peak with a strong intensity. We use a 1 \% prior uncertainty on a prior value that actually is 10 \% lower than the maximum intensity:</p><pre><code class="language-julia hljs">max_y = maximum(y_fit)
prior_main_peak = max_y-0.1*max_y
prior_main_peak_uncertainty = 0.01*prior_main_peak</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">7.27329821140079e-5</code></pre><p>Let&#39;s implement that in a <code>peaks_info</code> vector of peak parameters, uncertainties and boundaries.</p><p>Then we declare the context and have a look at the prior mode. If necessary we re-adjust it. Keep in mind that it should be fairly close to the solution, as the algorithms (here the quasi-Newton method) we use are local search algorithms.</p><pre><code class="language-julia hljs">peaks_info = [
        # (type, initial_params, uncertainties, lower_bounds, upper_bounds)
        (:gaussian,    [0.002, 950, 27],       [0.0005, 5.0,3.0], [0.0, 0.0, 0.0], [Inf, Inf, 60.0]),
        (:gaussian,    [0.0044, 1044, 40],      [0.0005, 5.0, 3.0], [0.0, 0.0, 0.0], [Inf, Inf, 60.0]),
        (:pseudovoigt,   [prior_main_peak, 1086, 30., 0.8], [prior_main_peak_uncertainty, 5.0, 3.0, 0.02], [0.0, 0.0, 0.0, 0.0], [Inf, Inf, 60.0, 1.0]),
        (:gaussian,    [0.0028, 1150, 45],      [0.0005, 5.0, 3.0], [0.0, 0.0, 0.0], [Inf, Inf, 60.0]),
        (:gaussian,    [0.0009, 1185, 30],      [0.0001, 5.0, 3.0], [0.0, 0.0, 0.0], [Inf, Inf, 60.0]),
    ]

# we declare the context of the fit
ctx = prepare_context(x_fit, y_fit, peaks_info, ese_y_fit)

# We plot the prior model
p = plot_fit(ctx, title=&quot;Prior model&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">No result provided, plotting the prior...</code></pre><p><img src="rsf_4.svg" alt/></p><pre><code class="language-julia hljs"># doing the fit
result = fit_peaks(ctx, backend=:Optim, relax=5, maxiter=100)

# we print the result using
print_params(result.peak_results)

# and we plot the fit
plot_fit(ctx, result.peak_results)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Peak 1 (gaussian):
  amplitude: 0.0015255 ± 2.0e-6
  center: 945.449 ± 0.019
  width: 24.911 ± 0.024
  area: 0.0809 ± 0.00017
Peak 2 (gaussian):
  amplitude: 0.004047 ± 2.4e-5
  center: 1060.53 ± 0.47
  width: 57.91 ± 0.25
  area: 0.499 ± 0.005
Peak 3 (pseudovoigt):
  amplitude: 0.004367 ± 3.7e-5
  center: 1086.163 ± 0.041
  width: 28.323 ± 0.062
  fraction: 0.2797 ± 0.004
  area: 0.2984 ± 0.003
Peak 4 (gaussian):
  amplitude: 0.000951 ± 3.3e-5
  center: 1140.14 ± 0.35
  width: 30.32 ± 0.35
  area: 0.0614 ± 0.0027
Peak 5 (gaussian):
  amplitude: 0.000835 ± 1.8e-5
  center: 1184.98 ± 0.89
  width: 39.42 ± 0.36
  area: 0.0701 ± 0.0021</code></pre><p><img src="rsf_5.svg" alt/></p><h2 id="Checking-errors-with-bootstrapping"><a class="docs-heading-anchor" href="#Checking-errors-with-bootstrapping">Checking errors with bootstrapping</a><a id="Checking-errors-with-bootstrapping-1"></a><a class="docs-heading-anchor-permalink" href="#Checking-errors-with-bootstrapping" title="Permalink"></a></h2><p>The error bars above appear fairly small... We check them using boostrapping. Again, we use a unrealistically low number of bootstrapped samples here because this code runs during documentation generation, but in reality you would like to increase <code>nb_boot</code> to something like 1000. I also fidled with <code>maxiter</code> to set it to a small value while still seeing convergence, such that we don&#39;t spend too much time in the quasi-Newton algorithm.</p><pre><code class="language-julia hljs">boot_samples, boot_results = bootstrap(x_fit, y_fit, ese_y_fit, peaks_info, nb_boot = 50, backend=:qGN, relax=5., maxiter=20)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([0.0015289599429511996 0.001521132270490236 … 0.0015243255150526817 0.001525319389225651; 945.4990411943977 945.423812082878 … 945.4631810516777 945.4163818669973; … ; 1187.166596140149 1189.9803523542505 … 1189.6854610975984 1189.6434011150861; 38.76497785370372 37.63998426573336 … 37.7408906421595 37.71387089510457], Any[(peak_type = :gaussian, params = Measurements.Measurement{Float64}[0.0015251 ± 2.2e-6, 945.478 ± 0.025, 24.918 ± 0.03], area = 0.0809 ± 0.00019), (peak_type = :gaussian, params = Measurements.Measurement{Float64}[0.004175 ± 2.8e-5, 1062.65 ± 0.45, 58.8 ± 0.22], area = 0.5227 ± 0.0051), (peak_type = :pseudovoigt, params = Measurements.Measurement{Float64}[0.004184 ± 4.1e-5, 1085.915 ± 0.066, 27.99 ± 0.1, 0.309 ± 0.0065], area = 0.286 ± 0.0037), (peak_type = :gaussian, params = Measurements.Measurement{Float64}[0.000961 ± 3.2e-5, 1142.56 ± 0.75, 32.11 ± 0.56], area = 0.0657 ± 0.0031), (peak_type = :gaussian, params = Measurements.Measurement{Float64}[0.000756 ± 3.1e-5, 1189.0 ± 1.4, 37.86 ± 0.53], area = 0.0609 ± 0.0033)])</code></pre><p>We can now print the bootstrapped results and compare the errors with those previously calculated from the Hessian:</p><pre><code class="language-julia hljs">print_params(boot_results)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Peak 1 (gaussian):
  amplitude: 0.0015251 ± 2.2e-6
  center: 945.478 ± 0.025
  width: 24.918 ± 0.03
  area: 0.0809 ± 0.00019
Peak 2 (gaussian):
  amplitude: 0.004175 ± 2.8e-5
  center: 1062.65 ± 0.45
  width: 58.8 ± 0.22
  area: 0.5227 ± 0.0051
Peak 3 (pseudovoigt):
  amplitude: 0.004184 ± 4.1e-5
  center: 1085.915 ± 0.066
  width: 27.99 ± 0.1
  fraction: 0.309 ± 0.0065
  area: 0.286 ± 0.0037
Peak 4 (gaussian):
  amplitude: 0.000961 ± 3.2e-5
  center: 1142.56 ± 0.75
  width: 32.11 ± 0.56
  area: 0.0657 ± 0.0031
Peak 5 (gaussian):
  amplitude: 0.000756 ± 3.1e-5
  center: 1189.0 ± 1.4
  width: 37.86 ± 0.53
  area: 0.0609 ± 0.0033</code></pre><p>OK, actually for this example, we see that the errors from the boostrap analysis are close to those calculated from the Hessian matrix. Everything thus seems OK.</p><p>Of course, a final quick visual inspection is always nice. This can be done by passing <code>boot_results</code> to the <code>plot_fit</code> function</p><pre><code class="language-julia hljs">plot_fit(ctx, boot_results)</code></pre><p><img src="rsf_6.svg" alt/></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="Full_processing.html">« Processing data</a><a class="docs-footer-nextpage" href="Smoothing.html">Smoothing data »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Thursday 24 April 2025 22:13">Thursday 24 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
